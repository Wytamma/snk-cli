{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"snk-cli","text":"<p>The dynamic CLI from snk. </p> <p>This site primary holds the reference docs for snk-cli </p>"},{"location":"reference/cli/","title":"Cli","text":""},{"location":"reference/cli/#src.snk_cli.cli.CLI","title":"<code>CLI</code>","text":"<p>             Bases: <code>DynamicTyper</code></p> <p>Constructor for the dynamic Snk CLI class.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_dir_path</code> <code>Path</code> <p>Path to the workflow directory.</p> <code>None</code> Side Effects <p>Initializes the CLI class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CLI(Path('/path/to/workflow'))\n</code></pre> Source code in <code>src/snk_cli/cli.py</code> <pre><code>class CLI(DynamicTyper):\n    \"\"\"\n    Constructor for the dynamic Snk CLI class.\n\n    Args:\n      workflow_dir_path (Path): Path to the workflow directory.\n\n    Side Effects:\n      Initializes the CLI class.\n\n    Examples:\n      &gt;&gt;&gt; CLI(Path('/path/to/workflow'))\n    \"\"\"\n\n    def __init__(self, workflow_dir_path: Path = None, *, pipeline_dir_path: Path = None, snk_config: SnkConfig = None) -&gt; None:\n        if pipeline_dir_path is not None:\n            # raise a deprecation warning\n            import warnings\n            warnings.warn(\n                \"The `pipeline_dir_path` argument is deprecated and will be removed in a future release. Use `workflow_dir_path` instead.\",\n                DeprecationWarning,\n            )\n            workflow_dir_path = pipeline_dir_path\n        if workflow_dir_path is None:\n            # get the calling frame (the frame of the function that called this function)\n            calling_frame = inspect.currentframe().f_back\n            # get the file path from the calling frame\n            workflow_dir_path = Path(calling_frame.f_globals[\"__file__\"])\n        else:\n            workflow_dir_path = Path(workflow_dir_path)\n        if workflow_dir_path.is_file():\n            workflow_dir_path = workflow_dir_path.parent\n        self.workflow = Workflow(path=workflow_dir_path)\n        self.snakemake_config = load_workflow_snakemake_config(workflow_dir_path)\n        if snk_config is None:\n            self.snk_config = SnkConfig.from_workflow_dir(\n                workflow_dir_path, create_if_not_exists=True\n            )\n        else:\n            self.snk_config = snk_config\n        if self.workflow.version:\n            self.version = self.workflow.version\n        else: \n            self.version = self.snk_config.version\n        self.options = build_dynamic_cli_options(self.snakemake_config, self.snk_config)\n        self.snakefile = self._find_snakefile()\n        self.conda_prefix_dir = self.workflow.conda_prefix_dir\n        self.singularity_prefix_dir = self.workflow.singularity_prefix_dir\n        self.name = self.workflow.name\n        self.verbose = False\n        if (\n            platform.system() == \"Darwin\"\n            and platform.processor() == \"arm\"\n            and not os.environ.get(\"CONDA_SUBDIR\")\n        ):\n            os.environ[\"CONDA_SUBDIR\"] = \"osx-64\"\n\n        # dynamically create the logo\n        self.logo = self._create_logo(\n            tagline=self.snk_config.tagline, font=self.snk_config.font\n        )\n        callback = self._create_callback()\n        callback.__doc__ = self.logo\n\n        # registration\n        self.register_callback(\n            callback,\n            invoke_without_command=True,\n            context_settings={\"help_option_names\": [\"-h\", \"--help\"]},\n        )\n\n        # Subcommands\n        if \"info\" in self.snk_config.commands:\n            self.register_command(self.info, help=\"Show information about the workflow.\")\n\n        if \"run\" in self.snk_config.commands:\n            run_app = RunApp(\n                conda_prefix_dir=self.conda_prefix_dir,\n                snk_config=self.snk_config,\n                singularity_prefix_dir=self.singularity_prefix_dir,\n                snakefile=self.snakefile,\n                workflow=self.workflow,\n                verbose=self.verbose,\n                logo=self.logo,\n                dynamic_run_options=self.options,\n            )\n            self.register_command(\n                run_app,\n                name=\"run\",\n            )\n        if \"config\" in self.snk_config.commands:\n            self.register_command(\n                ConfigApp(\n                    workflow=self.workflow,\n                    options=self.options,\n                ),\n                name=\"config\",\n            )\n        if self.workflow.environments and \"env\" in self.snk_config.commands:\n            self.register_group(\n                EnvApp(\n                    workflow=self.workflow,\n                    conda_prefix_dir=self.conda_prefix_dir,\n                    snakemake_config=self.snakemake_config,\n                    snakefile=self.snakefile,\n                ),\n                name=\"env\",\n                help=\"Access the workflow conda environments.\",\n            )\n        if self.workflow.scripts and \"script\" in self.snk_config.commands:\n            self.register_group(\n                ScriptApp(\n                    workflow=self.workflow,\n                    conda_prefix_dir=self.conda_prefix_dir,\n                    snakemake_config=self.snakemake_config,\n                    snakefile=self.snakefile,\n                ),\n                name=\"script\",\n                help=\"Access the workflow scripts.\",\n            )\n        if self.workflow.profiles and \"profile\" in self.snk_config.commands:\n            self.register_group(\n                ProfileApp(\n                    workflow=self.workflow,\n                ),\n                name=\"profile\",\n                help=\"Access the workflow profiles.\",\n            )\n\n    def _print_pipline_version(self, ctx: typer.Context, value: bool):\n        if value:\n            typer.echo(self.version)\n            raise typer.Exit()\n\n    def _print_pipline_path(self, ctx: typer.Context, value: bool):\n        if value:\n            typer.echo(self.workflow.path)\n            raise typer.Exit()\n\n    def _create_callback(self):\n        def callback(\n            ctx: typer.Context,\n            version: Optional[bool] = typer.Option(\n                None,\n                \"-v\",\n                \"--version\",\n                help=\"Show the workflow version and exit.\",\n                is_eager=True,\n                callback=self._print_pipline_version,\n                show_default=False,\n            ),\n            path: Optional[bool] = typer.Option(\n                None,\n                \"-p\",\n                \"--path\",\n                help=\"Show the workflow path and exit.\",\n                is_eager=True,\n                callback=self._print_pipline_path,\n                show_default=False,\n            ),\n        ):\n            if ctx.invoked_subcommand is None:\n                typer.echo(f\"{ctx.get_help()}\")\n\n        return callback\n\n    def _create_logo(\n        self, tagline=\"A Snakemake workflow CLI generated with snk\", font=\"small\"\n    ):\n        \"\"\"\n        Create a logo for the CLI.\n\n        Args:\n          tagline (str, optional): The tagline to include in the logo. Defaults to \"A Snakemake workflow CLI generated with snk\".\n          font (str, optional): The font to use for the logo. Defaults to \"small\".\n\n        Returns:\n          str: The logo.\n\n        Examples:\n          &gt;&gt;&gt; CLI._create_logo()\n        \"\"\"\n        if self.snk_config.art:\n            art = self.snk_config.art\n        else:\n            logo = self.snk_config.logo if self.snk_config.logo else self.name\n            art = text2art(logo, font=font)\n        doc = f\"\"\"\\b{art}\\b{tagline}\"\"\"\n        return doc\n\n    def _find_snakefile(self):\n        \"\"\"\n        Search possible snakefile locations.\n\n        Returns:\n          Path: The path to the snakefile.\n\n        Raises:\n          FileNotFoundError: If the snakefile is not found.\n\n        Examples:\n          &gt;&gt;&gt; CLI._find_snakefile()\n        \"\"\"\n        for path in SNAKEFILE_CHOICES:\n            if (self.workflow.path / path).exists():\n                return self.workflow.path / path\n        raise FileNotFoundError(\"Snakefile not found!\")\n\n    def info(self):\n        \"\"\"\n        Display information about current workflow install.\n\n        Returns:\n          str: A JSON string containing information about the current workflow install.\n\n        Examples:\n          &gt;&gt;&gt; CLI.info()\n        \"\"\"\n        import json\n\n        info_dict = {}\n        info_dict[\"name\"] = self.workflow.path.name\n        info_dict[\"version\"] = self.version\n        info_dict[\"snakefile\"] = str(self.snakefile)\n        info_dict[\"conda_prefix_dir\"] = str(self.conda_prefix_dir)\n        info_dict[\"singularity_prefix_dir\"] = str(self.singularity_prefix_dir)\n        info_dict[\"workflow_dir_path\"] = str(self.workflow.path)\n        typer.echo(json.dumps(info_dict, indent=2))\n</code></pre>"},{"location":"reference/cli/#src.snk_cli.cli.CLI.info","title":"<code>info()</code>","text":"<p>Display information about current workflow install.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A JSON string containing information about the current workflow install.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CLI.info()\n</code></pre> Source code in <code>src/snk_cli/cli.py</code> <pre><code>def info(self):\n    \"\"\"\n    Display information about current workflow install.\n\n    Returns:\n      str: A JSON string containing information about the current workflow install.\n\n    Examples:\n      &gt;&gt;&gt; CLI.info()\n    \"\"\"\n    import json\n\n    info_dict = {}\n    info_dict[\"name\"] = self.workflow.path.name\n    info_dict[\"version\"] = self.version\n    info_dict[\"snakefile\"] = str(self.snakefile)\n    info_dict[\"conda_prefix_dir\"] = str(self.conda_prefix_dir)\n    info_dict[\"singularity_prefix_dir\"] = str(self.singularity_prefix_dir)\n    info_dict[\"workflow_dir_path\"] = str(self.workflow.path)\n    typer.echo(json.dumps(info_dict, indent=2))\n</code></pre>"},{"location":"reference/config/","title":"Config","text":""},{"location":"reference/config/#src.snk_cli.config.config.InvalidSnkConfigError","title":"<code>InvalidSnkConfigError</code>","text":"<p>             Bases: <code>SnkConfigError</code>, <code>ValueError</code></p> <p>Thrown if the given SNK config appears to have an invalid format.</p> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>class InvalidSnkConfigError(SnkConfigError, ValueError):\n    \"\"\"\n    Thrown if the given SNK config appears to have an invalid format.\n    \"\"\"\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.MissingSnkConfigError","title":"<code>MissingSnkConfigError</code>","text":"<p>             Bases: <code>SnkConfigError</code>, <code>FileNotFoundError</code></p> <p>Thrown if the given SNK config file cannot be found.</p> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>class MissingSnkConfigError(SnkConfigError, FileNotFoundError):\n    \"\"\"\n    Thrown if the given SNK config file cannot be found.\n    \"\"\"\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.SnkConfig","title":"<code>SnkConfig</code>  <code>dataclass</code>","text":"<p>A dataclass for storing Snakemake workflow configuration.</p> <p>Attributes:</p> Name Type Description <code>art</code> <code>str</code> <p>The art to display in the CLI. Defaults to None.</p> <code>logo</code> <code>str</code> <p>The logo to display in the CLI. Defaults to None.</p> <code>tagline</code> <code>str</code> <p>The tagline to display in the CLI. Defaults to \"A Snakemake workflow CLI generated with Snk\".</p> <code>font</code> <code>str</code> <p>The font size for the CLI. Defaults to \"small\".</p> <code>version</code> <code>Optional[str]</code> <p>The version of the workflow. Defaults to None.</p> <code>conda</code> <code>bool</code> <p>Whether to use conda for managing environments. Defaults to True.</p> <code>resources</code> <code>List[Path]</code> <p>List of paths to additional resources. Defaults to an empty list.</p> <code>symlink_resources</code> <code>bool</code> <p>Whether to symlink resources instead of copying them. Defaults to False.</p> <code>skip_missing</code> <code>bool</code> <p>Whether to skip missing CLI options. Defaults to False.</p> <code>additional_snakemake_args</code> <code>List[str]</code> <p>List of additional Snakemake command-line arguments. Defaults to an empty list.</p> <code>commands</code> <code>List[str]</code> <p>List of subcommands to include in the CLI. Defaults to [\"run\", \"script\", \"env\", \"profile\", \"info\", \"config\"].</p> <code>cli</code> <code>dict</code> <p>Dictionary of CLI options and their values. Defaults to an empty dictionary.</p> <code>_snk_config_path</code> <code>Path</code> <p>The path to the SNK config file. Defaults to None.</p> Methods <p>from_path(snk_config_path: Path) -&gt; SnkConfig:   Load and validate Snk config from file.</p> <p>from_workflow_dir(workflow_dir_path: Path, create_if_not_exists: bool = False) -&gt; SnkConfig:   Load and validate SNK config from workflow directory.</p> <p>validate_resources(resources: List[Path]) -&gt; None:   Validate resources.</p> <p>add_resources(resources: List[Path], workflow_dir_path: Path = None) -&gt; None:   Add resources to the SNK config.</p> <p>to_yaml(path: Path) -&gt; None:   Write SNK config to YAML file.</p> <p>save() -&gt; None:   Save SNK config.</p> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>@dataclass\nclass SnkConfig:\n    \"\"\"\n    A dataclass for storing Snakemake workflow configuration.\n\n    Attributes:\n      art (str, optional): The art to display in the CLI. Defaults to None.\n      logo (str, optional): The logo to display in the CLI. Defaults to None.\n      tagline (str): The tagline to display in the CLI. Defaults to \"A Snakemake workflow CLI generated with Snk\".\n      font (str): The font size for the CLI. Defaults to \"small\".\n      version (Optional[str], optional): The version of the workflow. Defaults to None.\n      conda (bool): Whether to use conda for managing environments. Defaults to True.\n      resources (List[Path]): List of paths to additional resources. Defaults to an empty list.\n      symlink_resources (bool): Whether to symlink resources instead of copying them. Defaults to False.\n      skip_missing (bool): Whether to skip missing CLI options. Defaults to False.\n      additional_snakemake_args (List[str]): List of additional Snakemake command-line arguments. Defaults to an empty list.\n      commands (List[str]): List of subcommands to include in the CLI. Defaults to [\"run\", \"script\", \"env\", \"profile\", \"info\", \"config\"].\n      cli (dict): Dictionary of CLI options and their values. Defaults to an empty dictionary.\n      _snk_config_path (Path): The path to the SNK config file. Defaults to None.\n\n    Methods:\n      from_path(snk_config_path: Path) -&gt; SnkConfig:\n        Load and validate Snk config from file.\n\n      from_workflow_dir(workflow_dir_path: Path, create_if_not_exists: bool = False) -&gt; SnkConfig:\n        Load and validate SNK config from workflow directory.\n\n      validate_resources(resources: List[Path]) -&gt; None:\n        Validate resources.\n\n      add_resources(resources: List[Path], workflow_dir_path: Path = None) -&gt; None:\n        Add resources to the SNK config.\n\n      to_yaml(path: Path) -&gt; None:\n        Write SNK config to YAML file.\n\n      save() -&gt; None:\n        Save SNK config.\n    \"\"\"\n\n    art: str = None\n    logo: str = None\n    tagline: str = \"A Snakemake workflow CLI generated with Snk\"\n    font: str = \"small\"\n    version: Optional[str] = None\n    conda: bool = True\n    resources: List[Path] = field(default_factory=list)\n    symlink_resources: bool = False\n    skip_missing: bool = False # skip any missing cli options (i.e. those not in the snk file)\n    additional_snakemake_args: List[str] = field(default_factory=list)\n    commands: List[str] = field(default_factory=lambda: [\"run\", \"script\", \"env\", \"profile\", \"info\", \"config\"])\n    cli: dict = field(default_factory=dict)\n    _snk_config_path: Path = None\n\n    @classmethod\n    def from_path(cls, snk_config_path: Path):\n        \"\"\"\n        Load and validate Snk config from file.\n        Args:\n          snk_config_path (Path): Path to the SNK config file.\n        Returns:\n          SnkConfig: A SnkConfig object.\n        Raises:\n          FileNotFoundError: If the SNK config file is not found.\n        Examples:\n          &gt;&gt;&gt; SnkConfig.from_path(Path(\"snk.yaml\"))\n          SnkConfig(art=None, logo=None, tagline='A Snakemake workflow CLI generated with Snk', font='small', resources=[], annotations={}, symlink_resources=False, _snk_config_path=PosixPath('snk.yaml'))\n        \"\"\"\n        if not snk_config_path.exists():\n            raise MissingSnkConfigError(\n                f\"Could not find SNK config file: {snk_config_path}\"\n            ) from FileNotFoundError\n        # raise error if file is empty\n        if snk_config_path.stat().st_size == 0:\n            raise InvalidSnkConfigError(f\"SNK config file is empty: {snk_config_path}\") from ValueError\n\n        snk_config_dict = snakemake.load_configfile(snk_config_path)\n        snk_config_dict[\"version\"] = get_version_from_config(snk_config_path, snk_config_dict)\n        if \"annotations\" in snk_config_dict:\n            # TODO: remove annotations in the future\n            snk_config_dict[\"cli\"] = snk_config_dict[\"annotations\"]\n            del snk_config_dict[\"annotations\"]\n        if \"conda_required\" in snk_config_dict:\n            # TODO: remove conda_required in the future\n            snk_config_dict[\"conda\"] = snk_config_dict[\"conda_required\"]\n            del snk_config_dict[\"conda_required\"]\n        snk_config = cls(**snk_config_dict)\n        snk_config.resources = [\n            snk_config_path.parent / resource for resource in snk_config.resources\n        ]\n        snk_config.validate_resources(snk_config.resources)\n        snk_config._snk_config_path = snk_config_path\n        return snk_config\n\n    @classmethod\n    def from_workflow_dir(\n        cls, workflow_dir_path: Path, create_if_not_exists: bool = False\n    ):\n        \"\"\"\n        Load and validate SNK config from workflow directory.\n        Args:\n          workflow_dir_path (Path): Path to the workflow directory.\n          create_if_not_exists (bool): Whether to create a SNK config file if one does not exist.\n        Returns:\n          SnkConfig: A SnkConfig object.\n        Raises:\n          FileNotFoundError: If the SNK config file is not found.\n        Examples:\n          &gt;&gt;&gt; SnkConfig.from_workflow_dir(Path(\"workflow\"))\n          SnkConfig(art=None, logo=None, tagline='A Snakemake workflow CLI generated with Snk', font='small', resources=[], annotations={}, symlink_resources=False, _snk_config_path=PosixPath('workflow/snk.yaml'))\n        \"\"\"\n        if (workflow_dir_path / \"snk.yaml\").exists():\n            return cls.from_path(workflow_dir_path / \"snk.yaml\")\n        elif (workflow_dir_path / \".snk\").exists():\n            import warnings\n\n            warnings.warn(\n                \"Use of .snk will be deprecated in the future. Please use snk.yaml instead.\",\n                DeprecationWarning,\n            )\n            return cls.from_path(workflow_dir_path / \".snk\")\n        elif create_if_not_exists:\n            snk_config = cls(_snk_config_path=workflow_dir_path / \"snk.yaml\")\n            return snk_config\n        else:\n            raise FileNotFoundError(\n                f\"Could not find SNK config file in workflow directory: {workflow_dir_path}\"\n            )\n\n    def validate_resources(self, resources):\n        \"\"\"\n        Validate resources.\n        Args:\n          resources (List[Path]): List of resources to validate.\n        Raises:\n          FileNotFoundError: If a resource is not found.\n        Notes:\n          This function does not modify the resources list.\n        Examples:\n          &gt;&gt;&gt; SnkConfig.validate_resources([Path(\"resource1.txt\"), Path(\"resource2.txt\")])\n        \"\"\"\n        for resource in resources:\n            if not resource.exists():\n                raise FileNotFoundError(f\"Could not find resource: {resource}\")\n\n    def add_resources(self, resources: List[Path], workflow_dir_path: Path = None):\n        \"\"\"\n        Add resources to the SNK config.\n        Args:\n          resources (List[Path]): List of resources to add.\n          workflow_dir_path (Path): Path to the workflow directory.\n        Returns:\n          None\n        Side Effects:\n          Adds the resources to the SNK config.\n        Examples:\n          &gt;&gt;&gt; snk_config = SnkConfig()\n          &gt;&gt;&gt; snk_config.add_resources([Path(\"resource1.txt\"), Path(\"resource2.txt\")], Path(\"workflow\"))\n        \"\"\"\n        processed = []\n        for resource in resources:\n            if workflow_dir_path and not resource.is_absolute():\n                resource = workflow_dir_path / resource\n            processed.append(resource)\n        self.validate_resources(processed)\n        self.resources.extend(processed)\n\n    def to_yaml(self, path: Path) -&gt; None:\n        \"\"\"\n        Write SNK config to YAML file.\n        Args:\n          path (Path): Path to write the YAML file to.\n        Returns:\n          None\n        Side Effects:\n          Writes the SNK config to the specified path.\n        Examples:\n          &gt;&gt;&gt; snk_config = SnkConfig()\n          &gt;&gt;&gt; snk_config.to_yaml(Path(\"snk.yaml\"))\n        \"\"\"\n        config_dict = {k: v for k, v in vars(self).items() if not k.startswith(\"_\")}\n        with open(path, \"w\") as f:\n            yaml.dump(config_dict, f)\n\n    def save(self) -&gt; None:\n        \"\"\"\n        Save SNK config.\n        Args:\n          path (Path): Path to write the YAML file to.\n        Returns:\n          None\n        Side Effects:\n          Writes the SNK config to the path specified by _snk_config_path.\n        Examples:\n          &gt;&gt;&gt; snk_config = SnkConfig()\n          &gt;&gt;&gt; snk_config.save()\n        \"\"\"\n        self.to_yaml(self._snk_config_path)\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.SnkConfig.add_resources","title":"<code>add_resources(resources, workflow_dir_path=None)</code>","text":"<p>Add resources to the SNK config.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>List[Path]</code> <p>List of resources to add.</p> required <code>workflow_dir_path</code> <code>Path</code> <p>Path to the workflow directory.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Side Effects <p>Adds the resources to the SNK config.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; snk_config = SnkConfig()\n&gt;&gt;&gt; snk_config.add_resources([Path(\"resource1.txt\"), Path(\"resource2.txt\")], Path(\"workflow\"))\n</code></pre> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>def add_resources(self, resources: List[Path], workflow_dir_path: Path = None):\n    \"\"\"\n    Add resources to the SNK config.\n    Args:\n      resources (List[Path]): List of resources to add.\n      workflow_dir_path (Path): Path to the workflow directory.\n    Returns:\n      None\n    Side Effects:\n      Adds the resources to the SNK config.\n    Examples:\n      &gt;&gt;&gt; snk_config = SnkConfig()\n      &gt;&gt;&gt; snk_config.add_resources([Path(\"resource1.txt\"), Path(\"resource2.txt\")], Path(\"workflow\"))\n    \"\"\"\n    processed = []\n    for resource in resources:\n        if workflow_dir_path and not resource.is_absolute():\n            resource = workflow_dir_path / resource\n        processed.append(resource)\n    self.validate_resources(processed)\n    self.resources.extend(processed)\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.SnkConfig.from_path","title":"<code>from_path(snk_config_path)</code>  <code>classmethod</code>","text":"<p>Load and validate Snk config from file.</p> <p>Parameters:</p> Name Type Description Default <code>snk_config_path</code> <code>Path</code> <p>Path to the SNK config file.</p> required <p>Returns:</p> Name Type Description <code>SnkConfig</code> <p>A SnkConfig object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the SNK config file is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; SnkConfig.from_path(Path(\"snk.yaml\"))\nSnkConfig(art=None, logo=None, tagline='A Snakemake workflow CLI generated with Snk', font='small', resources=[], annotations={}, symlink_resources=False, _snk_config_path=PosixPath('snk.yaml'))\n</code></pre> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>@classmethod\ndef from_path(cls, snk_config_path: Path):\n    \"\"\"\n    Load and validate Snk config from file.\n    Args:\n      snk_config_path (Path): Path to the SNK config file.\n    Returns:\n      SnkConfig: A SnkConfig object.\n    Raises:\n      FileNotFoundError: If the SNK config file is not found.\n    Examples:\n      &gt;&gt;&gt; SnkConfig.from_path(Path(\"snk.yaml\"))\n      SnkConfig(art=None, logo=None, tagline='A Snakemake workflow CLI generated with Snk', font='small', resources=[], annotations={}, symlink_resources=False, _snk_config_path=PosixPath('snk.yaml'))\n    \"\"\"\n    if not snk_config_path.exists():\n        raise MissingSnkConfigError(\n            f\"Could not find SNK config file: {snk_config_path}\"\n        ) from FileNotFoundError\n    # raise error if file is empty\n    if snk_config_path.stat().st_size == 0:\n        raise InvalidSnkConfigError(f\"SNK config file is empty: {snk_config_path}\") from ValueError\n\n    snk_config_dict = snakemake.load_configfile(snk_config_path)\n    snk_config_dict[\"version\"] = get_version_from_config(snk_config_path, snk_config_dict)\n    if \"annotations\" in snk_config_dict:\n        # TODO: remove annotations in the future\n        snk_config_dict[\"cli\"] = snk_config_dict[\"annotations\"]\n        del snk_config_dict[\"annotations\"]\n    if \"conda_required\" in snk_config_dict:\n        # TODO: remove conda_required in the future\n        snk_config_dict[\"conda\"] = snk_config_dict[\"conda_required\"]\n        del snk_config_dict[\"conda_required\"]\n    snk_config = cls(**snk_config_dict)\n    snk_config.resources = [\n        snk_config_path.parent / resource for resource in snk_config.resources\n    ]\n    snk_config.validate_resources(snk_config.resources)\n    snk_config._snk_config_path = snk_config_path\n    return snk_config\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.SnkConfig.from_workflow_dir","title":"<code>from_workflow_dir(workflow_dir_path, create_if_not_exists=False)</code>  <code>classmethod</code>","text":"<p>Load and validate SNK config from workflow directory.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_dir_path</code> <code>Path</code> <p>Path to the workflow directory.</p> required <code>create_if_not_exists</code> <code>bool</code> <p>Whether to create a SNK config file if one does not exist.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SnkConfig</code> <p>A SnkConfig object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the SNK config file is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; SnkConfig.from_workflow_dir(Path(\"workflow\"))\nSnkConfig(art=None, logo=None, tagline='A Snakemake workflow CLI generated with Snk', font='small', resources=[], annotations={}, symlink_resources=False, _snk_config_path=PosixPath('workflow/snk.yaml'))\n</code></pre> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>@classmethod\ndef from_workflow_dir(\n    cls, workflow_dir_path: Path, create_if_not_exists: bool = False\n):\n    \"\"\"\n    Load and validate SNK config from workflow directory.\n    Args:\n      workflow_dir_path (Path): Path to the workflow directory.\n      create_if_not_exists (bool): Whether to create a SNK config file if one does not exist.\n    Returns:\n      SnkConfig: A SnkConfig object.\n    Raises:\n      FileNotFoundError: If the SNK config file is not found.\n    Examples:\n      &gt;&gt;&gt; SnkConfig.from_workflow_dir(Path(\"workflow\"))\n      SnkConfig(art=None, logo=None, tagline='A Snakemake workflow CLI generated with Snk', font='small', resources=[], annotations={}, symlink_resources=False, _snk_config_path=PosixPath('workflow/snk.yaml'))\n    \"\"\"\n    if (workflow_dir_path / \"snk.yaml\").exists():\n        return cls.from_path(workflow_dir_path / \"snk.yaml\")\n    elif (workflow_dir_path / \".snk\").exists():\n        import warnings\n\n        warnings.warn(\n            \"Use of .snk will be deprecated in the future. Please use snk.yaml instead.\",\n            DeprecationWarning,\n        )\n        return cls.from_path(workflow_dir_path / \".snk\")\n    elif create_if_not_exists:\n        snk_config = cls(_snk_config_path=workflow_dir_path / \"snk.yaml\")\n        return snk_config\n    else:\n        raise FileNotFoundError(\n            f\"Could not find SNK config file in workflow directory: {workflow_dir_path}\"\n        )\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.SnkConfig.save","title":"<code>save()</code>","text":"<p>Save SNK config.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to write the YAML file to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Side Effects <p>Writes the SNK config to the path specified by _snk_config_path.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; snk_config = SnkConfig()\n&gt;&gt;&gt; snk_config.save()\n</code></pre> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"\n    Save SNK config.\n    Args:\n      path (Path): Path to write the YAML file to.\n    Returns:\n      None\n    Side Effects:\n      Writes the SNK config to the path specified by _snk_config_path.\n    Examples:\n      &gt;&gt;&gt; snk_config = SnkConfig()\n      &gt;&gt;&gt; snk_config.save()\n    \"\"\"\n    self.to_yaml(self._snk_config_path)\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.SnkConfig.to_yaml","title":"<code>to_yaml(path)</code>","text":"<p>Write SNK config to YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to write the YAML file to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Side Effects <p>Writes the SNK config to the specified path.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; snk_config = SnkConfig()\n&gt;&gt;&gt; snk_config.to_yaml(Path(\"snk.yaml\"))\n</code></pre> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>def to_yaml(self, path: Path) -&gt; None:\n    \"\"\"\n    Write SNK config to YAML file.\n    Args:\n      path (Path): Path to write the YAML file to.\n    Returns:\n      None\n    Side Effects:\n      Writes the SNK config to the specified path.\n    Examples:\n      &gt;&gt;&gt; snk_config = SnkConfig()\n      &gt;&gt;&gt; snk_config.to_yaml(Path(\"snk.yaml\"))\n    \"\"\"\n    config_dict = {k: v for k, v in vars(self).items() if not k.startswith(\"_\")}\n    with open(path, \"w\") as f:\n        yaml.dump(config_dict, f)\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.SnkConfig.validate_resources","title":"<code>validate_resources(resources)</code>","text":"<p>Validate resources.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>List[Path]</code> <p>List of resources to validate.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If a resource is not found.</p> Notes <p>This function does not modify the resources list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; SnkConfig.validate_resources([Path(\"resource1.txt\"), Path(\"resource2.txt\")])\n</code></pre> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>def validate_resources(self, resources):\n    \"\"\"\n    Validate resources.\n    Args:\n      resources (List[Path]): List of resources to validate.\n    Raises:\n      FileNotFoundError: If a resource is not found.\n    Notes:\n      This function does not modify the resources list.\n    Examples:\n      &gt;&gt;&gt; SnkConfig.validate_resources([Path(\"resource1.txt\"), Path(\"resource2.txt\")])\n    \"\"\"\n    for resource in resources:\n        if not resource.exists():\n            raise FileNotFoundError(f\"Could not find resource: {resource}\")\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.SnkConfigError","title":"<code>SnkConfigError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for all SNK config exceptions.</p> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>class SnkConfigError(Exception):\n    \"\"\"\n    Base class for all SNK config exceptions.\n    \"\"\"\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.get_config_from_workflow_dir","title":"<code>get_config_from_workflow_dir(workflow_dir_path)</code>","text":"<p>Get the config file from a workflow directory.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_dir_path</code> <code>Path</code> <p>Path to the workflow directory.</p> required <p>Returns:</p> Name Type Description <code>Path</code> <p>Path to the config file, or None if not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_config_from_workflow_dir(Path(\"workflow\"))\nPosixPath('workflow/config.yaml')\n</code></pre> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>def get_config_from_workflow_dir(workflow_dir_path: Path):\n    \"\"\"\n    Get the config file from a workflow directory.\n    Args:\n      workflow_dir_path (Path): Path to the workflow directory.\n    Returns:\n      Path: Path to the config file, or None if not found.\n    Examples:\n      &gt;&gt;&gt; get_config_from_workflow_dir(Path(\"workflow\"))\n      PosixPath('workflow/config.yaml')\n    \"\"\"\n    for path in [\n        Path(\"config\") / \"config.yaml\",\n        Path(\"config\") / \"config.yml\",\n        \"config.yaml\",\n        \"config.yml\",\n    ]:\n        if (workflow_dir_path / path).exists():\n            return workflow_dir_path / path\n    return None\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.config.load_workflow_snakemake_config","title":"<code>load_workflow_snakemake_config(workflow_dir_path)</code>","text":"<p>Load the Snakemake config from a workflow directory.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_dir_path</code> <code>Path</code> <p>Path to the workflow directory.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The Snakemake config.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; load_workflow_snakemake_config(Path(\"workflow\"))\n{'inputs': {'data': 'data.txt'}, 'outputs': {'results': 'results.txt'}}\n</code></pre> Source code in <code>src/snk_cli/config/config.py</code> <pre><code>def load_workflow_snakemake_config(workflow_dir_path: Path):\n    \"\"\"\n    Load the Snakemake config from a workflow directory.\n    Args:\n      workflow_dir_path (Path): Path to the workflow directory.\n    Returns:\n      dict: The Snakemake config.\n    Examples:\n      &gt;&gt;&gt; load_workflow_snakemake_config(Path(\"workflow\"))\n      {'inputs': {'data': 'data.txt'}, 'outputs': {'results': 'results.txt'}}\n    \"\"\"\n    workflow_config_path = get_config_from_workflow_dir(workflow_dir_path)\n    if not workflow_config_path or not workflow_config_path.exists():\n        return {}\n    return snakemake.load_configfile(workflow_config_path)\n</code></pre>"},{"location":"reference/config/#src.snk_cli.config.utils.get_version_from_config","title":"<code>get_version_from_config(config_path, config_dict=None)</code>","text":"<p>Get the version from the config file or config dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path</code> <p>Path to the config file.</p> required <code>config_dict</code> <code>dict</code> <p>Config dictionary. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The version.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the version file (about.py) is not found.</p> <code>KeyError</code> <p>If the version key is not found in the version file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_version_from_config(Path(\"config.yaml\"))\n'0.1.0'\n&gt;&gt;&gt; get_version_from_config(Path(\"config.yaml\"), {\"version\": \"0.2.0\"})\n'0.2.0'\n</code></pre> Source code in <code>src/snk_cli/config/utils.py</code> <pre><code>def get_version_from_config(config_path: Path, config_dict: dict = None) -&gt; str:\n    \"\"\"\n    Get the version from the config file or config dictionary.\n\n    Args:\n      config_path (Path): Path to the config file.\n      config_dict (dict, optional): Config dictionary. Defaults to None.\n\n    Returns:\n      str: The version.\n\n    Raises:\n      FileNotFoundError: If the version file (__about__.py) is not found.\n      KeyError: If the __version__ key is not found in the version file.\n\n    Examples:\n      &gt;&gt;&gt; get_version_from_config(Path(\"config.yaml\"))\n      '0.1.0'\n      &gt;&gt;&gt; get_version_from_config(Path(\"config.yaml\"), {\"version\": \"0.2.0\"})\n      '0.2.0'\n    \"\"\"\n    if not config_dict:\n        config_dict = load_configfile(config_path)\n\n    if \"version\" not in config_dict:\n        return None \n    if config_dict[\"version\"] is None:\n        return None\n    version = str(config_dict[\"version\"])\n    if \"__about__.py\" in version:\n        # load version from __about__.py\n        about_path = config_path.parent / version\n        if not about_path.exists():\n            raise FileNotFoundError(\n                f\"Could not find version file: {about_path}\"\n            )\n        about = {}\n        exec(about_path.read_text(), about)\n        try:\n            version = about[\"__version__\"]\n        except KeyError as e:\n            raise KeyError(\n                f\"Could not find __version__ in file: {about_path}\"\n            ) from e\n    return version\n</code></pre>"},{"location":"reference/dynamic_typer/","title":"Dynamic typer","text":""},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper","title":"<code>DynamicTyper</code>","text":"Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>class DynamicTyper:\n    app: typer.Typer\n\n    def __init__(self):\n        self.app = typer.Typer()\n\n    def __call__(self):\n        \"\"\"\n        Invoke the CLI.\n\n        Side Effects:\n          Invokes the CLI.\n\n        Examples:\n          &gt;&gt;&gt; CLI(Path('/path/to/workflow'))()\n        \"\"\"\n        self.app()\n\n    def _set_app(self):\n        \"\"\"\n        Set the app attribute.\n\n        Side Effects:\n          Sets the app attribute to a Typer object.\n        \"\"\"\n        if not hasattr(self, \"app\"):\n          self.app = typer.Typer()\n\n    def register_default_command(self, command: Callable, **command_kwargs) -&gt; None:\n        \"\"\"\n        Register a default command to the CLI.\n\n        Args:\n          command (Callable): The command to register.\n\n        Side Effects:\n          Registers the command to the CLI.\n\n        Examples:\n          &gt;&gt;&gt; CLI.register_default_command(my_command)\n        \"\"\"\n        from makefun import with_signature\n        from inspect import signature, Parameter\n\n        command_signature = signature(command)\n        params = list(command_signature.parameters.values())\n        has_ctx = any([p.name == \"ctx\" for p in params])\n        if not has_ctx:\n            params.insert(\n                0,\n                Parameter(\n                    \"ctx\",\n                    kind=Parameter.POSITIONAL_OR_KEYWORD,\n                    annotation=typer.Context,\n                ),\n            )\n            command_signature = command_signature.replace(parameters=params)\n\n        @with_signature(command_signature)\n        def wrapper(ctx: typer.Context, *args, **kwargs):\n            if ctx.invoked_subcommand is None:\n                if has_ctx:\n                    return command(ctx, *args, **kwargs)\n                return command(*args, **kwargs)\n\n        self.register_callback(wrapper, invoke_without_command=True, **command_kwargs)\n\n    def register_command(\n        self, command: Callable, dynamic_options=None, **command_kwargs\n    ) -&gt; None:\n        \"\"\"\n        Register a command to the CLI.\n\n        Args:\n          command (Callable): The command to register.\n          dynamic_options (List[Option], optional): A list of dynamic options to add to the command.\n\n        Side Effects:\n          Registers the command to the CLI.\n\n        Examples:\n          &gt;&gt;&gt; CLI.register_command(my_command)\n          &gt;&gt;&gt; CLI.register_command(my_command, dynamic_options=[option1, option2])\n        \"\"\"\n        self._set_app()\n        if dynamic_options is not None:\n            command = self.add_dynamic_options(command, dynamic_options)\n        if isinstance(command, DynamicTyper):\n            self.app.registered_commands.extend(command.app.registered_commands)\n        else:\n            self.app.command(**command_kwargs)(command)\n\n    def register_callback(self, command: Callable, **command_kwargs) -&gt; None:\n        \"\"\"\n        Register a callback to the CLI.\n\n        Args:\n          command (Callable): The callback to register.\n\n        Side Effects:\n          Registers the callback to the CLI.\n\n        Examples:\n          &gt;&gt;&gt; CLI.register_callback(my_callback)\n        \"\"\"\n        self._set_app()\n        self.app.callback(**command_kwargs)(command)\n\n    def register_group(self, group: \"DynamicTyper\", **command_kwargs) -&gt; None:\n        \"\"\"\n        Register a subcommand group to the CLI.\n\n        Args:\n          group (DynamicTyper): The subcommand group to register.\n\n        Side Effects:\n          Registers the subcommand group to the CLI.\n\n        Examples:\n          &gt;&gt;&gt; CLI.register_group(my_group)\n        \"\"\"\n        self._set_app()\n        self.app.add_typer(group.app, **command_kwargs)\n\n    def _create_cli_parameter(self, option: Option):\n        \"\"\"\n        Creates a parameter for a CLI option.\n\n        Args:\n          option (Option): An Option object containing the option's name, type, required status, default value, and help message.\n\n        Returns:\n          Parameter: A parameter object for the CLI option.\n\n        Examples:\n          &gt;&gt;&gt; option = Option(name='foo', type='int', required=True, default=0, help='A number')\n          &gt;&gt;&gt; create_cli_parameter(option)\n          Parameter('foo', kind=Parameter.POSITIONAL_OR_KEYWORD, default=typer.Option(..., help='[CONFIG] A number'), annotation=int)\n        \"\"\"\n        return Parameter(\n            option.name,\n            kind=Parameter.POSITIONAL_OR_KEYWORD,\n            default=typer.Option(\n                ... if option.required else option.default,\n                *[option.flag, option.short_flag] if option.short else [],\n                help=f\"{option.help}\",\n                rich_help_panel=\"Workflow Configuration\",\n                hidden=option.hidden,\n            ),\n            annotation=option.type,\n        )\n\n    def check_if_option_passed_via_command_line(self, option: Option):\n        \"\"\"\n        Check if an option is passed via the command line.\n\n        Args:\n          option (Option): An Option object containing the option's name, type, required status, default value, and help message.\n\n        Returns:\n          bool: Whether the option is passed via the command line.\n        \"\"\"\n        if option.flag in sys.argv:\n            return True\n        elif option.type is bool and f\"--no-{option.flag[2:]}\" in sys.argv:\n            # Check for boolean flags like --foo/--no-foo\n            return True\n        elif option.short and option.short_flag in sys.argv:\n            return True\n        return False\n\n    def add_dynamic_options(self, func: Callable, options: List[Option]):\n        \"\"\"\n        Function to add dynamic options to a command.\n\n        Args:\n          func (Callable): The command to which the dynamic options should be added.\n          options (List[Option]): A list of Option objects containing the options to add.\n\n        Returns:\n          Callable: A function with the dynamic options added.\n\n        Examples:\n          &gt;&gt;&gt; my_func = add_dynamic_options_to_function(my_func, [option1, option2])\n          &gt;&gt;&gt; my_func\n        \"\"\"\n        func_sig = signature(func)\n        params = list(func_sig.parameters.values())\n        for op in options[::-1]:\n            params.insert(1, self._create_cli_parameter(op))\n        new_sig = func_sig.replace(parameters=params)\n\n        @with_signature(func_signature=new_sig, func_name=func.__name__)\n        def func_wrapper(*args, **kwargs):\n            \"\"\"\n            Wraps a function with dynamic options.\n\n            Args:\n              *args: Variable length argument list.\n              **kwargs: Arbitrary keyword arguments.\n\n            Returns:\n              Callable: A wrapped function with the dynamic options added.\n\n            Notes:\n              This function is used in the `add_dynamic_options_to_function` function.\n            \"\"\"\n            flat_config = None\n\n            if kwargs.get(\"configfile\"):\n                from snakemake import load_configfile\n                from .utils import flatten\n\n                snakemake_config = load_configfile(kwargs[\"configfile\"])\n                flat_config = flatten(snakemake_config)\n\n            for snk_cli_option in options:\n\n                def add_option_to_args():\n                    kwargs[\"ctx\"].args.extend([f\"--{snk_cli_option.name}\", kwargs[snk_cli_option.name]])\n\n                passed_via_command_line = self.check_if_option_passed_via_command_line(\n                    snk_cli_option\n                )\n\n                if flat_config is None:\n                    # If no config file is provided then all options should be added to the arguments\n                    # later on we will check to see if they differ from any defaults\n                    add_option_to_args()\n                elif passed_via_command_line:\n                    # If an option is passed via the command line if should override the default\n                    add_option_to_args()\n                elif flat_config and snk_cli_option.original_key not in flat_config:\n                    # If a config file is provided and the snk_cli_option key isn't in it, \n                    # add the snk_cli_option to the arguments\n                    add_option_to_args()\n\n            kwargs = {\n                k: v for k, v in kwargs.items() if k in func_sig.parameters.keys()\n            }\n            return func(*args, **kwargs)\n\n        return func_wrapper\n\n    def error(self, msg, exit=True):\n        \"\"\"\n        Logs an error message (red) and exits (optional).\n\n        Args:\n          msg (str): The error message to log.\n          exit (bool): Whether to exit after logging the error message.\n        \"\"\"\n        typer.secho(msg, fg=\"red\", err=True)\n        if exit:\n            raise typer.Exit(1)\n\n    def success(self, msg):\n        \"\"\"\n        Logs a success message (green).\n\n        Args:\n          msg (str): The success message to log.\n        \"\"\"\n        typer.secho(msg, fg=\"green\")\n\n    def log(self, msg, color=\"yellow\", stderr=True):\n        \"\"\"\n        Logs a message (yellow).\n\n        Args:\n          msg (str): The message to log.\n          color (str, optional): The color of the log message. Defaults to \"yellow\".\n          stderr (bool, optional): Whether to log the message to stderr. Defaults to True.\n        \"\"\"\n        typer.secho(msg, fg=color, err=stderr)\n\n    def echo(self, msg):\n        \"\"\"\n        Prints a message.\n\n        Args:\n          msg (str): The message to print.\n        \"\"\"\n        typer.echo(msg)\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.__call__","title":"<code>__call__()</code>","text":"<p>Invoke the CLI.</p> Side Effects <p>Invokes the CLI.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CLI(Path('/path/to/workflow'))()\n</code></pre> Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def __call__(self):\n    \"\"\"\n    Invoke the CLI.\n\n    Side Effects:\n      Invokes the CLI.\n\n    Examples:\n      &gt;&gt;&gt; CLI(Path('/path/to/workflow'))()\n    \"\"\"\n    self.app()\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.add_dynamic_options","title":"<code>add_dynamic_options(func, options)</code>","text":"<p>Function to add dynamic options to a command.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The command to which the dynamic options should be added.</p> required <code>options</code> <code>List[Option]</code> <p>A list of Option objects containing the options to add.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <p>A function with the dynamic options added.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_func = add_dynamic_options_to_function(my_func, [option1, option2])\n&gt;&gt;&gt; my_func\n</code></pre> Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def add_dynamic_options(self, func: Callable, options: List[Option]):\n    \"\"\"\n    Function to add dynamic options to a command.\n\n    Args:\n      func (Callable): The command to which the dynamic options should be added.\n      options (List[Option]): A list of Option objects containing the options to add.\n\n    Returns:\n      Callable: A function with the dynamic options added.\n\n    Examples:\n      &gt;&gt;&gt; my_func = add_dynamic_options_to_function(my_func, [option1, option2])\n      &gt;&gt;&gt; my_func\n    \"\"\"\n    func_sig = signature(func)\n    params = list(func_sig.parameters.values())\n    for op in options[::-1]:\n        params.insert(1, self._create_cli_parameter(op))\n    new_sig = func_sig.replace(parameters=params)\n\n    @with_signature(func_signature=new_sig, func_name=func.__name__)\n    def func_wrapper(*args, **kwargs):\n        \"\"\"\n        Wraps a function with dynamic options.\n\n        Args:\n          *args: Variable length argument list.\n          **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n          Callable: A wrapped function with the dynamic options added.\n\n        Notes:\n          This function is used in the `add_dynamic_options_to_function` function.\n        \"\"\"\n        flat_config = None\n\n        if kwargs.get(\"configfile\"):\n            from snakemake import load_configfile\n            from .utils import flatten\n\n            snakemake_config = load_configfile(kwargs[\"configfile\"])\n            flat_config = flatten(snakemake_config)\n\n        for snk_cli_option in options:\n\n            def add_option_to_args():\n                kwargs[\"ctx\"].args.extend([f\"--{snk_cli_option.name}\", kwargs[snk_cli_option.name]])\n\n            passed_via_command_line = self.check_if_option_passed_via_command_line(\n                snk_cli_option\n            )\n\n            if flat_config is None:\n                # If no config file is provided then all options should be added to the arguments\n                # later on we will check to see if they differ from any defaults\n                add_option_to_args()\n            elif passed_via_command_line:\n                # If an option is passed via the command line if should override the default\n                add_option_to_args()\n            elif flat_config and snk_cli_option.original_key not in flat_config:\n                # If a config file is provided and the snk_cli_option key isn't in it, \n                # add the snk_cli_option to the arguments\n                add_option_to_args()\n\n        kwargs = {\n            k: v for k, v in kwargs.items() if k in func_sig.parameters.keys()\n        }\n        return func(*args, **kwargs)\n\n    return func_wrapper\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.check_if_option_passed_via_command_line","title":"<code>check_if_option_passed_via_command_line(option)</code>","text":"<p>Check if an option is passed via the command line.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option</code> <p>An Option object containing the option's name, type, required status, default value, and help message.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the option is passed via the command line.</p> Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def check_if_option_passed_via_command_line(self, option: Option):\n    \"\"\"\n    Check if an option is passed via the command line.\n\n    Args:\n      option (Option): An Option object containing the option's name, type, required status, default value, and help message.\n\n    Returns:\n      bool: Whether the option is passed via the command line.\n    \"\"\"\n    if option.flag in sys.argv:\n        return True\n    elif option.type is bool and f\"--no-{option.flag[2:]}\" in sys.argv:\n        # Check for boolean flags like --foo/--no-foo\n        return True\n    elif option.short and option.short_flag in sys.argv:\n        return True\n    return False\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.echo","title":"<code>echo(msg)</code>","text":"<p>Prints a message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to print.</p> required Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def echo(self, msg):\n    \"\"\"\n    Prints a message.\n\n    Args:\n      msg (str): The message to print.\n    \"\"\"\n    typer.echo(msg)\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.error","title":"<code>error(msg, exit=True)</code>","text":"<p>Logs an error message (red) and exits (optional).</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The error message to log.</p> required <code>exit</code> <code>bool</code> <p>Whether to exit after logging the error message.</p> <code>True</code> Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def error(self, msg, exit=True):\n    \"\"\"\n    Logs an error message (red) and exits (optional).\n\n    Args:\n      msg (str): The error message to log.\n      exit (bool): Whether to exit after logging the error message.\n    \"\"\"\n    typer.secho(msg, fg=\"red\", err=True)\n    if exit:\n        raise typer.Exit(1)\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.log","title":"<code>log(msg, color='yellow', stderr=True)</code>","text":"<p>Logs a message (yellow).</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log.</p> required <code>color</code> <code>str</code> <p>The color of the log message. Defaults to \"yellow\".</p> <code>'yellow'</code> <code>stderr</code> <code>bool</code> <p>Whether to log the message to stderr. Defaults to True.</p> <code>True</code> Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def log(self, msg, color=\"yellow\", stderr=True):\n    \"\"\"\n    Logs a message (yellow).\n\n    Args:\n      msg (str): The message to log.\n      color (str, optional): The color of the log message. Defaults to \"yellow\".\n      stderr (bool, optional): Whether to log the message to stderr. Defaults to True.\n    \"\"\"\n    typer.secho(msg, fg=color, err=stderr)\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.register_callback","title":"<code>register_callback(command, **command_kwargs)</code>","text":"<p>Register a callback to the CLI.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Callable</code> <p>The callback to register.</p> required Side Effects <p>Registers the callback to the CLI.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CLI.register_callback(my_callback)\n</code></pre> Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def register_callback(self, command: Callable, **command_kwargs) -&gt; None:\n    \"\"\"\n    Register a callback to the CLI.\n\n    Args:\n      command (Callable): The callback to register.\n\n    Side Effects:\n      Registers the callback to the CLI.\n\n    Examples:\n      &gt;&gt;&gt; CLI.register_callback(my_callback)\n    \"\"\"\n    self._set_app()\n    self.app.callback(**command_kwargs)(command)\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.register_command","title":"<code>register_command(command, dynamic_options=None, **command_kwargs)</code>","text":"<p>Register a command to the CLI.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Callable</code> <p>The command to register.</p> required <code>dynamic_options</code> <code>List[Option]</code> <p>A list of dynamic options to add to the command.</p> <code>None</code> Side Effects <p>Registers the command to the CLI.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CLI.register_command(my_command)\n&gt;&gt;&gt; CLI.register_command(my_command, dynamic_options=[option1, option2])\n</code></pre> Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def register_command(\n    self, command: Callable, dynamic_options=None, **command_kwargs\n) -&gt; None:\n    \"\"\"\n    Register a command to the CLI.\n\n    Args:\n      command (Callable): The command to register.\n      dynamic_options (List[Option], optional): A list of dynamic options to add to the command.\n\n    Side Effects:\n      Registers the command to the CLI.\n\n    Examples:\n      &gt;&gt;&gt; CLI.register_command(my_command)\n      &gt;&gt;&gt; CLI.register_command(my_command, dynamic_options=[option1, option2])\n    \"\"\"\n    self._set_app()\n    if dynamic_options is not None:\n        command = self.add_dynamic_options(command, dynamic_options)\n    if isinstance(command, DynamicTyper):\n        self.app.registered_commands.extend(command.app.registered_commands)\n    else:\n        self.app.command(**command_kwargs)(command)\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.register_default_command","title":"<code>register_default_command(command, **command_kwargs)</code>","text":"<p>Register a default command to the CLI.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Callable</code> <p>The command to register.</p> required Side Effects <p>Registers the command to the CLI.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CLI.register_default_command(my_command)\n</code></pre> Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def register_default_command(self, command: Callable, **command_kwargs) -&gt; None:\n    \"\"\"\n    Register a default command to the CLI.\n\n    Args:\n      command (Callable): The command to register.\n\n    Side Effects:\n      Registers the command to the CLI.\n\n    Examples:\n      &gt;&gt;&gt; CLI.register_default_command(my_command)\n    \"\"\"\n    from makefun import with_signature\n    from inspect import signature, Parameter\n\n    command_signature = signature(command)\n    params = list(command_signature.parameters.values())\n    has_ctx = any([p.name == \"ctx\" for p in params])\n    if not has_ctx:\n        params.insert(\n            0,\n            Parameter(\n                \"ctx\",\n                kind=Parameter.POSITIONAL_OR_KEYWORD,\n                annotation=typer.Context,\n            ),\n        )\n        command_signature = command_signature.replace(parameters=params)\n\n    @with_signature(command_signature)\n    def wrapper(ctx: typer.Context, *args, **kwargs):\n        if ctx.invoked_subcommand is None:\n            if has_ctx:\n                return command(ctx, *args, **kwargs)\n            return command(*args, **kwargs)\n\n    self.register_callback(wrapper, invoke_without_command=True, **command_kwargs)\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.register_group","title":"<code>register_group(group, **command_kwargs)</code>","text":"<p>Register a subcommand group to the CLI.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>DynamicTyper</code> <p>The subcommand group to register.</p> required Side Effects <p>Registers the subcommand group to the CLI.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CLI.register_group(my_group)\n</code></pre> Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def register_group(self, group: \"DynamicTyper\", **command_kwargs) -&gt; None:\n    \"\"\"\n    Register a subcommand group to the CLI.\n\n    Args:\n      group (DynamicTyper): The subcommand group to register.\n\n    Side Effects:\n      Registers the subcommand group to the CLI.\n\n    Examples:\n      &gt;&gt;&gt; CLI.register_group(my_group)\n    \"\"\"\n    self._set_app()\n    self.app.add_typer(group.app, **command_kwargs)\n</code></pre>"},{"location":"reference/dynamic_typer/#src.snk_cli.dynamic_typer.DynamicTyper.success","title":"<code>success(msg)</code>","text":"<p>Logs a success message (green).</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The success message to log.</p> required Source code in <code>src/snk_cli/dynamic_typer.py</code> <pre><code>def success(self, msg):\n    \"\"\"\n    Logs a success message (green).\n\n    Args:\n      msg (str): The success message to log.\n    \"\"\"\n    typer.secho(msg, fg=\"green\")\n</code></pre>"},{"location":"reference/options/","title":"Options","text":""},{"location":"reference/options/#src.snk_cli.options.utils.build_dynamic_cli_options","title":"<code>build_dynamic_cli_options(snakemake_config, snk_config)</code>","text":"<p>Builds a list of options from a snakemake config and a snk config.</p> <p>Parameters:</p> Name Type Description Default <code>snakemake_config</code> <code>dict</code> <p>A snakemake config.</p> required <code>snk_config</code> <code>SnkConfig</code> <p>A snk config.</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List[dict]: A list of options.</p> Source code in <code>src/snk_cli/options/utils.py</code> <pre><code>def build_dynamic_cli_options(\n    snakemake_config: dict, snk_config: SnkConfig\n) -&gt; List[dict]:\n    \"\"\"\n    Builds a list of options from a snakemake config and a snk config.\n\n    Args:\n      snakemake_config (dict): A snakemake config.\n      snk_config (SnkConfig): A snk config.\n\n    Returns:\n      List[dict]: A list of options.\n    \"\"\"\n    flat_config = flatten(snakemake_config)\n    flat_annotations = flatten(snk_config.cli)\n    annotation_keys = get_keys_from_annotation(flat_annotations)\n    options = {}\n\n    # For every parameter in the config, create an option from the corresponding annotation\n    for parameter in flat_config:\n        if parameter not in annotation_keys and snk_config.skip_missing:\n            continue\n        options[parameter] = create_option_from_annotation(\n            parameter,\n            flat_annotations,\n            default_values=flat_config,\n        )\n\n    # For every annotation not in config, create an option with default values    \n    for key in annotation_keys:\n        if key not in options:\n            # in annotation but not in config\n            options[key] = create_option_from_annotation(\n                key,\n                flat_annotations,\n                default_values={},\n                from_annotation=True,\n            )\n    return list(options.values())\n</code></pre>"},{"location":"reference/options/#src.snk_cli.options.utils.create_option_from_annotation","title":"<code>create_option_from_annotation(annotation_key, annotation_values, default_values, from_annotation=False)</code>","text":"<p>Create an Option object from a given annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_key</code> <code>str</code> <p>The key in the annotations.</p> required <code>annotation_values</code> <code>dict</code> <p>The dictionary of annotation values.</p> required <code>default_values</code> <code>dict</code> <p>Default value from config.</p> required <code>from_annotation</code> <code>bool</code> <p>Whether the option is from an annotation. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Option</code> <code>Option</code> <p>An Option object.</p> Source code in <code>src/snk_cli/options/utils.py</code> <pre><code>def create_option_from_annotation(\n    annotation_key: str,\n    annotation_values: dict,\n    default_values: dict,\n    from_annotation: bool = False,\n) -&gt; Option:\n    \"\"\"\n    Create an Option object from a given annotation.\n\n    Args:\n      annotation_key (str): The key in the annotations.\n      annotation_values (dict): The dictionary of annotation values.\n      default_values (dict): Default value from config.\n      from_annotation (bool, optional): Whether the option is from an annotation. Defaults to False.\n\n    Returns:\n      Option: An Option object.\n    \"\"\"\n    config_default = default_values.get(annotation_key, None)\n\n    default = annotation_values.get(f\"{annotation_key}:default\", config_default)\n    updated = False\n    if config_default is None or default != config_default:\n        updated = True\n    type = annotation_values.get(f\"{annotation_key}:type\", get_default_type(default))\n    assert (\n        type is not None\n    ), f\"Type for {annotation_key} should be one of {', '.join(types.keys())}.\"\n    annotation_type = types.get(\n        type.lower(), List[str] if \"list\" in type.lower() else str\n    )\n    name = annotation_values.get(\n        f\"{annotation_key}:name\", annotation_key.replace(\":\", \"_\")\n    ).replace(\"-\", \"_\")\n    short = annotation_values.get(f\"{annotation_key}:short\", None)\n    hidden = annotation_values.get(f\"{annotation_key}:hidden\", False)\n    return Option(\n        name=name,\n        original_key=annotation_key,\n        default=annotation_values.get(f\"{annotation_key}:default\", default),\n        updated=updated,\n        help=annotation_values.get(f\"{annotation_key}:help\", \"\"),\n        type=annotation_type,\n        required=annotation_values.get(f\"{annotation_key}:required\", False),\n        short=short,\n        flag=f\"--{name.replace('_', '-')}\",\n        short_flag=f\"-{short}\" if short else None,\n        hidden=hidden,\n        from_annotation=from_annotation,\n    )\n</code></pre>"},{"location":"reference/subcommands/","title":"Subcommands","text":""},{"location":"reference/subcommands/#src.snk_cli.subcommands.run.RunApp","title":"<code>RunApp</code>","text":"<p>             Bases: <code>DynamicTyper</code></p> Source code in <code>src/snk_cli/subcommands/run.py</code> <pre><code>class RunApp(DynamicTyper):\n    def __init__(\n        self,\n        conda_prefix_dir: Path,\n        snk_config: SnkConfig,\n        singularity_prefix_dir: Path,\n        snakefile: Path,\n        workflow: Workflow,\n        logo: str,\n        verbose: bool,\n        dynamic_run_options: List[Option],\n    ):\n        self.conda_prefix_dir = conda_prefix_dir\n        self.singularity_prefix_dir = singularity_prefix_dir\n        self.snk_config = snk_config\n        self.snakefile = snakefile\n        self.workflow = workflow\n        self.verbose = verbose\n        self.logo = logo\n        self.options = dynamic_run_options\n\n        self.register_command(\n            self.run,\n            dynamic_options=self.options,\n            help=\"Run the workflow.\\n\\nAll unrecognized arguments are passed onto Snakemake.\",\n            context_settings={\n                \"allow_extra_args\": True,\n                \"ignore_unknown_options\": True,\n                \"help_option_names\": [\"-h\", \"--help\"],\n            },\n        )\n\n    def _print_snakemake_help(value: bool):\n        \"\"\"\n        Print the snakemake help and exit.\n\n        Args:\n          value (bool): If True, print the snakemake help and exit.\n\n        Side Effects:\n          Prints the snakemake help and exits.\n\n        Examples:\n          &gt;&gt;&gt; RunApp._print_snakemake_help(True)\n        \"\"\"\n        if value:\n            import snakemake\n\n            snakemake.main(\"-h\")\n\n    def run(\n        self,\n        ctx: typer.Context,\n        configfile: Path = typer.Option(\n            None,\n            \"--config\",\n            help=\"Path to snakemake config file. Overrides existing workflow configuration.\",\n            exists=True,\n            dir_okay=False,\n        ),\n        resource: List[Path] = typer.Option(\n            [],\n            \"--resource\",\n            \"-r\",\n            help=\"Additional resources to copy from workflow directory at run time.\",\n        ),\n        profile: Optional[str] = typer.Option(\n            None,\n            \"--profile\",\n            \"-p\",\n            help=\"Name of profile to use for configuring Snakemake.\",\n        ),\n        dry: bool = typer.Option(\n            False,\n            \"--dry\",\n            \"-n\",\n            help=\"Do not execute anything, and display what would be done.\",\n        ),\n        lock: bool = typer.Option(\n            False, \"--lock\", \"-l\", help=\"Lock the working directory.\"\n        ),\n        dag: Optional[Path] = typer.Option(\n            None,\n            \"--dag\",\n            \"-d\",\n            help=\"Save directed acyclic graph to file. Must end in .pdf, .png or .svg\",\n            callback=dag_filetype_callback,\n        ),\n        cores: int = typer.Option(\n            None,\n            \"--cores\",\n            \"-c\",\n            help=\"Set the number of cores to use. If None will use all cores.\",\n        ),\n        no_conda: bool = typer.Option(\n            False,\n            \"--no-conda\",\n            help=\"Do not use conda environments.\",\n        ),\n        keep_resources: bool = typer.Option(\n            False,\n            \"--keep-resources\",\n            help=\"Keep resources after pipeline completes.\",\n        ),\n        keep_snakemake: bool = typer.Option(\n            False,\n            \"--keep-snakemake\",\n            help=\"Keep .snakemake folder after pipeline completes.\",\n        ),\n        verbose: Optional[bool] = typer.Option(\n            False,\n            \"--verbose\",\n            \"-v\",\n            help=\"Run workflow in verbose mode.\",\n        ),\n        help_snakemake: Optional[bool] = typer.Option(\n            False,\n            \"--help-snakemake\",\n            \"-hs\",\n            help=\"Print the snakemake help and exit.\",\n            is_eager=True,\n            callback=_print_snakemake_help,\n            show_default=False,\n        ),\n    ):\n        \"\"\"\n        Run the workflow.\n\n        Args:\n          ctx (typer.Context): The typer context.\n          configfile (Path, optional): Path to snakemake config file. Overrides existing workflow configuration. Defaults to None.\n          resource (List[Path], optional): Additional resources to copy from workflow directory at run time. Defaults to [].\n          profile (str, optional): Name of profile to use for configuring Snakemake. Defaults to None.\n          dry (bool, optional): Do not execute anything, and display what would be done. Defaults to False.\n          lock (bool, optional): Lock the working directory. Defaults to False.\n          dag (Path, optional): Save directed acyclic graph to file. Must end in .pdf, .png or .svg. Defaults to None.\n          cores (int, optional): Set the number of cores to use. If None will use all cores. Defaults to None.\n          no_conda (bool, optional): Do not use conda environments. Defaults to False.\n          keep_resources (bool, optional): Keep resources after pipeline completes. Defaults to False.\n          keep_snakemake (bool, optional): Keep .snakemake folder after pipeline completes. Defaults to False.\n          verbose (bool, optional): Run workflow in verbose mode. Defaults to False.\n          help_snakemake (bool, optional): Print the snakemake help and exit. Defaults to False.\n\n        Side Effects:\n          Runs the workflow.\n\n        Examples:\n          &gt;&gt;&gt; RunApp.run(target='my_target', configfile=Path('/path/to/config.yaml'), resource=[Path('/path/to/resource')], verbose=True)\n        \"\"\"\n        import snakemake\n        import shutil\n        import sys\n\n        self.verbose = verbose\n        args = []\n        if self.snk_config.additional_snakemake_args:\n            if verbose:\n                self.log(\n                    f\"Using additional snakemake args: {' '.join(self.snk_config.additional_snakemake_args)}\",\n                    color=typer.colors.MAGENTA\n                )\n            args.extend(self.snk_config.additional_snakemake_args)\n        if not cores:\n            cores = \"all\"\n        args.extend(\n            [\n                \"--rerun-incomplete\",\n                f\"--cores={cores}\",\n            ]\n        )\n        if self.singularity_prefix_dir and \"--use-singularity\" in ctx.args:\n            # only set prefix if --use-singularity is explicitly called\n            args.append(f\"--singularity-prefix={self.singularity_prefix_dir}\")\n            if verbose:\n                self.log(f\"Using singularity prefix: {self.singularity_prefix_dir}\", color=typer.colors.MAGENTA)\n        if not self.snakefile.exists():\n            raise ValueError(\"Could not find Snakefile\")  # this should occur at install\n        else:\n            args.append(f\"--snakefile={self.snakefile}\")\n\n        if not configfile:\n            configfile = get_config_from_workflow_dir(self.workflow.path)\n        if configfile:\n            args.append(f\"--configfile={configfile}\")\n\n        if profile:\n            found_profile = [p for p in self.workflow.profiles if profile == p.name]\n            if found_profile:\n                profile = found_profile[0]\n            args.append(f\"--profile={profile}\")\n\n        # Set up conda frontend\n        conda_found = check_command_available(\"conda\")\n        if not conda_found and verbose:\n            typer.secho(\n                \"Conda not found! Install conda to use environments.\\n\",\n                fg=typer.colors.MAGENTA,\n                err=True,\n            )\n\n        if conda_found and self.snk_config.conda and not no_conda:\n            args.extend(\n                [\n                    \"--use-conda\",\n                    f\"--conda-prefix={self.conda_prefix_dir}\",\n                ]\n            )\n            if not check_command_available(\"mamba\"):\n                if verbose:\n                    typer.secho(\n                        \"Could not find mamba, using conda instead...\",\n                        fg=typer.colors.MAGENTA,\n                        err=True,\n                    )\n                args.append(\"--conda-frontend=conda\")\n            else:\n                args.append(\"--conda-frontend=mamba\")\n\n        if verbose:\n            args.insert(0, \"--verbose\")\n\n        if dry:\n            args.append(\"--dryrun\")\n\n        if not lock:\n            args.append(\"--nolock\")\n        targets_and_or_snakemake, config_dict_list = parse_config_args(\n            ctx.args, options=self.options\n        )\n        targets_and_or_snakemake = [\n            t.replace(\"--snake-\", \"-\") for t in targets_and_or_snakemake\n        ]\n        args.extend(targets_and_or_snakemake)\n        configs = []\n        for config_dict in config_dict_list:\n            for key, value in config_dict.items():\n                configs.append(f\"{key}={value}\")\n\n        if configs:\n            args.extend([\"--config\", *configs])\n        if verbose:\n            typer.secho(f\"snakemake {' '.join(args)}\\n\", fg=typer.colors.MAGENTA, err=True)\n        if not keep_snakemake and Path(\".snakemake\").exists():\n            keep_snakemake = True\n        try:\n            self.snk_config.add_resources(resource, self.workflow.path)\n        except FileNotFoundError as e:\n            self.error(str(e))\n        with self._copy_resources(\n            self.snk_config.resources,\n            cleanup=not keep_resources,\n            symlink_resources=self.snk_config.symlink_resources,\n        ):\n            if dag:\n                return self._save_dag(snakemake_args=args, filename=dag)\n            try:\n                snakemake.parse_config = parse_config_monkeypatch\n                snakemake.main(args)\n            except SystemExit as e:\n                status = int(str(e))\n                if status:\n                    sys.exit(status)\n        if not keep_snakemake and Path(\".snakemake\").exists():\n            typer.secho(\"Cleaning up '.snakemake' folder... use --keep-snakemake to keep.\", fg=typer.colors.YELLOW, err=True)\n            shutil.rmtree(\".snakemake\")\n\n    def _save_dag(self, snakemake_args: List[str], filename: Path):\n        from contextlib import redirect_stdout\n        import snakemake\n        import subprocess\n        import io\n\n        snakemake_args.append(\"--dag\")\n\n        fileType = filename.suffix.lstrip(\".\")\n\n        # Create a file-like object to redirect the stdout\n        snakemake_output = io.StringIO()\n        # Use redirect_stdout to redirect stdout to the file-like object\n        with redirect_stdout(snakemake_output):\n            # Capture the output of snakemake.main(args) using a try-except block\n            try:\n                snakemake.parse_config = parse_config_monkeypatch\n                snakemake.main(snakemake_args)\n            except SystemExit:  # Catch SystemExit exception to prevent termination\n                pass\n        try:\n            snakemake_output = snakemake_output.getvalue()\n            if \"snakemake_dag\" not in snakemake_output:\n                self.error(\"Could not generate dag!\", exit=True)\n            # discard everything before digraph snakemake_dag\n            filtered_lines = (\n                \"digraph snakemake_dag\" + snakemake_output.split(\"snakemake_dag\")[1]\n            )\n            echo_process = subprocess.Popen(\n                [\"echo\", filtered_lines], stdout=subprocess.PIPE\n            )\n            dot_process = subprocess.Popen(\n                [\"dot\", f\"-T{fileType}\"],\n                stdin=echo_process.stdout,\n                stdout=subprocess.PIPE,\n            )\n            with open(filename, \"w\") as output_file:\n                if self.verbose:\n                    typer.secho(f\"Saving dag to {filename}\", fg=typer.colors.MAGENTA, err=True)\n                subprocess.run([\"cat\"], stdin=dot_process.stdout, stdout=output_file)\n        except (subprocess.CalledProcessError, FileNotFoundError):\n            typer.echo(\"dot command not found!\", fg=typer.colors.RED, err=True)\n            raise typer.Exit(1)\n\n    @contextmanager\n    def _copy_resources(\n        self, resources: List[Path], cleanup: bool, symlink_resources: bool = False\n    ):\n        \"\"\"\n        Copy resources to the current working directory.\n\n        Args:\n          resources (List[Path]): A list of paths to the resources to copy.\n          cleanup (bool): If True, the resources will be removed after the function exits.\n          symlink_resources (bool, optional): If True, symlink the resources instead of copying them. Defaults to False.\n\n        Side Effects:\n          Copies the resources to the current working directory.\n\n        Returns:\n          Generator: A generator object.\n\n        Examples:\n          &gt;&gt;&gt; with RunApp._copy_resources(resources, cleanup=True):\n          ...     # do something\n        \"\"\"\n        import os\n        import shutil\n\n        copied_resources = []\n\n        def copy_resource(src: Path, dst: Path, symlink: bool = False):\n            if self.verbose:\n                typer.secho(\n                    f\"  - Copying resource '{src}' to '{dst}'\",\n                    fg=typer.colors.MAGENTA,\n                    err=True,\n                )\n            target_is_directory = src.is_dir()\n            if symlink:\n                os.symlink(src, dst, target_is_directory=target_is_directory)\n            elif target_is_directory:\n                shutil.copytree(src, dst)\n            else:\n                shutil.copy(src, dst)\n\n        def remove_resource(resource: Path):\n            if resource.is_symlink():\n                resource.unlink()\n            elif resource.is_dir():\n                shutil.rmtree(resource)\n            else:\n                os.remove(resource)\n\n        resources_folder = self.workflow.path / \"resources\"\n        if resources_folder.exists():\n            resources.insert(0, Path(\"resources\"))\n        if self.verbose and resources:\n            typer.secho(\n                f\"Copying {len(resources)} resources to working directory...\",\n                fg=typer.colors.MAGENTA,\n                err=True,\n            )\n        try:\n            for resource in resources:\n                abs_path = self.workflow.path / resource\n                destination = Path(\".\") / resource.name\n                if not destination.exists():\n                    # make sure you don't delete files that are already there...\n                    copy_resource(abs_path, destination, symlink=symlink_resources)\n                    copied_resources.append(destination)\n                elif self.verbose:\n                    typer.secho(\n                        f\"  - Resource '{resource.name}' already exists! Skipping...\",\n                        fg=typer.colors.MAGENTA,\n                        err=True,\n                    )\n            yield\n        finally:\n            if not cleanup:\n                return\n            for copied_resource in copied_resources:\n                if copied_resource.exists():\n                    if self.verbose:\n                        typer.secho(\n                            f\"Deleting '{copied_resource.name}' resource...\",\n                            fg=typer.colors.MAGENTA,\n                            err=True,\n                        )\n                    remove_resource(copied_resource)\n</code></pre>"},{"location":"reference/subcommands/#src.snk_cli.subcommands.run.RunApp.run","title":"<code>run(ctx, configfile=typer.Option(None, '--config', help='Path to snakemake config file. Overrides existing workflow configuration.', exists=True, dir_okay=False), resource=typer.Option([], '--resource', '-r', help='Additional resources to copy from workflow directory at run time.'), profile=typer.Option(None, '--profile', '-p', help='Name of profile to use for configuring Snakemake.'), dry=typer.Option(False, '--dry', '-n', help='Do not execute anything, and display what would be done.'), lock=typer.Option(False, '--lock', '-l', help='Lock the working directory.'), dag=typer.Option(None, '--dag', '-d', help='Save directed acyclic graph to file. Must end in .pdf, .png or .svg', callback=dag_filetype_callback), cores=typer.Option(None, '--cores', '-c', help='Set the number of cores to use. If None will use all cores.'), no_conda=typer.Option(False, '--no-conda', help='Do not use conda environments.'), keep_resources=typer.Option(False, '--keep-resources', help='Keep resources after pipeline completes.'), keep_snakemake=typer.Option(False, '--keep-snakemake', help='Keep .snakemake folder after pipeline completes.'), verbose=typer.Option(False, '--verbose', '-v', help='Run workflow in verbose mode.'), help_snakemake=typer.Option(False, '--help-snakemake', '-hs', help='Print the snakemake help and exit.', is_eager=True, callback=_print_snakemake_help, show_default=False))</code>","text":"<p>Run the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>The typer context.</p> required <code>configfile</code> <code>Path</code> <p>Path to snakemake config file. Overrides existing workflow configuration. Defaults to None.</p> <code>typer.Option(None, '--config', help='Path to snakemake config file. Overrides existing workflow configuration.', exists=True, dir_okay=False)</code> <code>resource</code> <code>List[Path]</code> <p>Additional resources to copy from workflow directory at run time. Defaults to [].</p> <code>typer.Option([], '--resource', '-r', help='Additional resources to copy from workflow directory at run time.')</code> <code>profile</code> <code>str</code> <p>Name of profile to use for configuring Snakemake. Defaults to None.</p> <code>typer.Option(None, '--profile', '-p', help='Name of profile to use for configuring Snakemake.')</code> <code>dry</code> <code>bool</code> <p>Do not execute anything, and display what would be done. Defaults to False.</p> <code>typer.Option(False, '--dry', '-n', help='Do not execute anything, and display what would be done.')</code> <code>lock</code> <code>bool</code> <p>Lock the working directory. Defaults to False.</p> <code>typer.Option(False, '--lock', '-l', help='Lock the working directory.')</code> <code>dag</code> <code>Path</code> <p>Save directed acyclic graph to file. Must end in .pdf, .png or .svg. Defaults to None.</p> <code>typer.Option(None, '--dag', '-d', help='Save directed acyclic graph to file. Must end in .pdf, .png or .svg', callback=dag_filetype_callback)</code> <code>cores</code> <code>int</code> <p>Set the number of cores to use. If None will use all cores. Defaults to None.</p> <code>typer.Option(None, '--cores', '-c', help='Set the number of cores to use. If None will use all cores.')</code> <code>no_conda</code> <code>bool</code> <p>Do not use conda environments. Defaults to False.</p> <code>typer.Option(False, '--no-conda', help='Do not use conda environments.')</code> <code>keep_resources</code> <code>bool</code> <p>Keep resources after pipeline completes. Defaults to False.</p> <code>typer.Option(False, '--keep-resources', help='Keep resources after pipeline completes.')</code> <code>keep_snakemake</code> <code>bool</code> <p>Keep .snakemake folder after pipeline completes. Defaults to False.</p> <code>typer.Option(False, '--keep-snakemake', help='Keep .snakemake folder after pipeline completes.')</code> <code>verbose</code> <code>bool</code> <p>Run workflow in verbose mode. Defaults to False.</p> <code>typer.Option(False, '--verbose', '-v', help='Run workflow in verbose mode.')</code> <code>help_snakemake</code> <code>bool</code> <p>Print the snakemake help and exit. Defaults to False.</p> <code>typer.Option(False, '--help-snakemake', '-hs', help='Print the snakemake help and exit.', is_eager=True, callback=_print_snakemake_help, show_default=False)</code> Side Effects <p>Runs the workflow.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; RunApp.run(target='my_target', configfile=Path('/path/to/config.yaml'), resource=[Path('/path/to/resource')], verbose=True)\n</code></pre> Source code in <code>src/snk_cli/subcommands/run.py</code> <pre><code>def run(\n    self,\n    ctx: typer.Context,\n    configfile: Path = typer.Option(\n        None,\n        \"--config\",\n        help=\"Path to snakemake config file. Overrides existing workflow configuration.\",\n        exists=True,\n        dir_okay=False,\n    ),\n    resource: List[Path] = typer.Option(\n        [],\n        \"--resource\",\n        \"-r\",\n        help=\"Additional resources to copy from workflow directory at run time.\",\n    ),\n    profile: Optional[str] = typer.Option(\n        None,\n        \"--profile\",\n        \"-p\",\n        help=\"Name of profile to use for configuring Snakemake.\",\n    ),\n    dry: bool = typer.Option(\n        False,\n        \"--dry\",\n        \"-n\",\n        help=\"Do not execute anything, and display what would be done.\",\n    ),\n    lock: bool = typer.Option(\n        False, \"--lock\", \"-l\", help=\"Lock the working directory.\"\n    ),\n    dag: Optional[Path] = typer.Option(\n        None,\n        \"--dag\",\n        \"-d\",\n        help=\"Save directed acyclic graph to file. Must end in .pdf, .png or .svg\",\n        callback=dag_filetype_callback,\n    ),\n    cores: int = typer.Option(\n        None,\n        \"--cores\",\n        \"-c\",\n        help=\"Set the number of cores to use. If None will use all cores.\",\n    ),\n    no_conda: bool = typer.Option(\n        False,\n        \"--no-conda\",\n        help=\"Do not use conda environments.\",\n    ),\n    keep_resources: bool = typer.Option(\n        False,\n        \"--keep-resources\",\n        help=\"Keep resources after pipeline completes.\",\n    ),\n    keep_snakemake: bool = typer.Option(\n        False,\n        \"--keep-snakemake\",\n        help=\"Keep .snakemake folder after pipeline completes.\",\n    ),\n    verbose: Optional[bool] = typer.Option(\n        False,\n        \"--verbose\",\n        \"-v\",\n        help=\"Run workflow in verbose mode.\",\n    ),\n    help_snakemake: Optional[bool] = typer.Option(\n        False,\n        \"--help-snakemake\",\n        \"-hs\",\n        help=\"Print the snakemake help and exit.\",\n        is_eager=True,\n        callback=_print_snakemake_help,\n        show_default=False,\n    ),\n):\n    \"\"\"\n    Run the workflow.\n\n    Args:\n      ctx (typer.Context): The typer context.\n      configfile (Path, optional): Path to snakemake config file. Overrides existing workflow configuration. Defaults to None.\n      resource (List[Path], optional): Additional resources to copy from workflow directory at run time. Defaults to [].\n      profile (str, optional): Name of profile to use for configuring Snakemake. Defaults to None.\n      dry (bool, optional): Do not execute anything, and display what would be done. Defaults to False.\n      lock (bool, optional): Lock the working directory. Defaults to False.\n      dag (Path, optional): Save directed acyclic graph to file. Must end in .pdf, .png or .svg. Defaults to None.\n      cores (int, optional): Set the number of cores to use. If None will use all cores. Defaults to None.\n      no_conda (bool, optional): Do not use conda environments. Defaults to False.\n      keep_resources (bool, optional): Keep resources after pipeline completes. Defaults to False.\n      keep_snakemake (bool, optional): Keep .snakemake folder after pipeline completes. Defaults to False.\n      verbose (bool, optional): Run workflow in verbose mode. Defaults to False.\n      help_snakemake (bool, optional): Print the snakemake help and exit. Defaults to False.\n\n    Side Effects:\n      Runs the workflow.\n\n    Examples:\n      &gt;&gt;&gt; RunApp.run(target='my_target', configfile=Path('/path/to/config.yaml'), resource=[Path('/path/to/resource')], verbose=True)\n    \"\"\"\n    import snakemake\n    import shutil\n    import sys\n\n    self.verbose = verbose\n    args = []\n    if self.snk_config.additional_snakemake_args:\n        if verbose:\n            self.log(\n                f\"Using additional snakemake args: {' '.join(self.snk_config.additional_snakemake_args)}\",\n                color=typer.colors.MAGENTA\n            )\n        args.extend(self.snk_config.additional_snakemake_args)\n    if not cores:\n        cores = \"all\"\n    args.extend(\n        [\n            \"--rerun-incomplete\",\n            f\"--cores={cores}\",\n        ]\n    )\n    if self.singularity_prefix_dir and \"--use-singularity\" in ctx.args:\n        # only set prefix if --use-singularity is explicitly called\n        args.append(f\"--singularity-prefix={self.singularity_prefix_dir}\")\n        if verbose:\n            self.log(f\"Using singularity prefix: {self.singularity_prefix_dir}\", color=typer.colors.MAGENTA)\n    if not self.snakefile.exists():\n        raise ValueError(\"Could not find Snakefile\")  # this should occur at install\n    else:\n        args.append(f\"--snakefile={self.snakefile}\")\n\n    if not configfile:\n        configfile = get_config_from_workflow_dir(self.workflow.path)\n    if configfile:\n        args.append(f\"--configfile={configfile}\")\n\n    if profile:\n        found_profile = [p for p in self.workflow.profiles if profile == p.name]\n        if found_profile:\n            profile = found_profile[0]\n        args.append(f\"--profile={profile}\")\n\n    # Set up conda frontend\n    conda_found = check_command_available(\"conda\")\n    if not conda_found and verbose:\n        typer.secho(\n            \"Conda not found! Install conda to use environments.\\n\",\n            fg=typer.colors.MAGENTA,\n            err=True,\n        )\n\n    if conda_found and self.snk_config.conda and not no_conda:\n        args.extend(\n            [\n                \"--use-conda\",\n                f\"--conda-prefix={self.conda_prefix_dir}\",\n            ]\n        )\n        if not check_command_available(\"mamba\"):\n            if verbose:\n                typer.secho(\n                    \"Could not find mamba, using conda instead...\",\n                    fg=typer.colors.MAGENTA,\n                    err=True,\n                )\n            args.append(\"--conda-frontend=conda\")\n        else:\n            args.append(\"--conda-frontend=mamba\")\n\n    if verbose:\n        args.insert(0, \"--verbose\")\n\n    if dry:\n        args.append(\"--dryrun\")\n\n    if not lock:\n        args.append(\"--nolock\")\n    targets_and_or_snakemake, config_dict_list = parse_config_args(\n        ctx.args, options=self.options\n    )\n    targets_and_or_snakemake = [\n        t.replace(\"--snake-\", \"-\") for t in targets_and_or_snakemake\n    ]\n    args.extend(targets_and_or_snakemake)\n    configs = []\n    for config_dict in config_dict_list:\n        for key, value in config_dict.items():\n            configs.append(f\"{key}={value}\")\n\n    if configs:\n        args.extend([\"--config\", *configs])\n    if verbose:\n        typer.secho(f\"snakemake {' '.join(args)}\\n\", fg=typer.colors.MAGENTA, err=True)\n    if not keep_snakemake and Path(\".snakemake\").exists():\n        keep_snakemake = True\n    try:\n        self.snk_config.add_resources(resource, self.workflow.path)\n    except FileNotFoundError as e:\n        self.error(str(e))\n    with self._copy_resources(\n        self.snk_config.resources,\n        cleanup=not keep_resources,\n        symlink_resources=self.snk_config.symlink_resources,\n    ):\n        if dag:\n            return self._save_dag(snakemake_args=args, filename=dag)\n        try:\n            snakemake.parse_config = parse_config_monkeypatch\n            snakemake.main(args)\n        except SystemExit as e:\n            status = int(str(e))\n            if status:\n                sys.exit(status)\n    if not keep_snakemake and Path(\".snakemake\").exists():\n        typer.secho(\"Cleaning up '.snakemake' folder... use --keep-snakemake to keep.\", fg=typer.colors.YELLOW, err=True)\n        shutil.rmtree(\".snakemake\")\n</code></pre>"},{"location":"reference/subcommands/#src.snk_cli.subcommands.run.parse_config_monkeypatch","title":"<code>parse_config_monkeypatch(args)</code>","text":"<p>Monkeypatch the parse_config function from snakemake.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>The arguments to parse.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The parsed config.</p> Source code in <code>src/snk_cli/subcommands/run.py</code> <pre><code>def parse_config_monkeypatch(args):\n    \"\"\"\n    Monkeypatch the parse_config function from snakemake.\n\n    Args:\n      args: The arguments to parse.\n\n    Returns:\n      dict: The parsed config.\n    \"\"\"\n    import yaml\n    import snakemake\n    import re\n\n    class NoDatesSafeLoader(yaml.SafeLoader):\n        @classmethod\n        def remove_implicit_resolver(cls, tag_to_remove):\n            \"\"\"\n            Remove implicit resolvers for a particular tag.\n\n            Args:\n              tag_to_remove: The tag to remove.\n\n            Side Effects:\n              Modifies the implicit resolvers for the specified tag.\n            \"\"\"\n            if \"yaml_implicit_resolvers\" not in cls.__dict__:\n                cls.yaml_implicit_resolvers = cls.yaml_implicit_resolvers.copy()\n\n            for first_letter, mappings in cls.yaml_implicit_resolvers.items():\n                cls.yaml_implicit_resolvers[first_letter] = [\n                    (tag, regexp) for tag, regexp in mappings if tag != tag_to_remove\n                ]\n\n    NoDatesSafeLoader.remove_implicit_resolver(\"tag:yaml.org,2002:timestamp\")\n\n    def _yaml_safe_load(s):\n        \"\"\"\n        Load yaml string safely.\n\n        Args:\n        s (str): The yaml string to load.\n\n        Returns:\n        The loaded yaml object.\n        \"\"\"\n        s = s.replace(\": None\", \": null\")\n        return yaml.load(s, Loader=NoDatesSafeLoader)\n\n    parsers = [int, float, snakemake._bool_parser, _yaml_safe_load, str]\n    config = dict()\n    if args.config is not None:\n        valid = re.compile(r\"[a-zA-Z_]\\w*$\")\n        for entry in args.config:\n            key, val = snakemake.parse_key_value_arg(\n                entry,\n                errmsg=\"Invalid config definition: Config entries have to be defined as name=value pairs.\",\n            )\n            if not valid.match(key):\n                raise ValueError(\n                    \"Invalid config definition: Config entry must start with a valid identifier.\"\n                )\n            v = None\n            if val == \"\" or val == \"None\":\n                snakemake.update_config(config, {key: v})\n                continue\n            for parser in parsers:\n                try:\n                    v = parser(val)\n                    # avoid accidental interpretation as function\n                    if not callable(v):\n                        break\n                except:\n                    pass\n            assert v is not None\n            snakemake.update_config(config, {key: v})\n    return config\n</code></pre>"},{"location":"reference/subcommands/#src.snk_cli.subcommands.config.ConfigApp","title":"<code>ConfigApp</code>","text":"<p>             Bases: <code>DynamicTyper</code></p> Source code in <code>src/snk_cli/subcommands/config.py</code> <pre><code>class ConfigApp(DynamicTyper):\n    def __init__(self, workflow: Workflow, options: List[Option]):\n        \"\"\"\n        Initializes the ConfigApp class.\n\n        Args:\n          workflow (Workflow): The workflow to configure.\n        \"\"\"\n        self.options = options\n        self.workflow = workflow\n        self.register_command(self.config, help=\"Show the workflow configuration.\")\n\n    def config(\n        self, ctx: typer.Context, pretty: bool = typer.Option(False, \"--pretty\", \"-p\")\n    ):\n        \"\"\"\n        Prints the configuration for the workflow.\n\n        Args:\n          ctx (typer.Context): The Typer context.\n          pretty (bool, optional): Whether to print the configuration in a pretty format. Defaults to False.\n\n        Returns:\n          None\n\n        Examples:\n          &gt;&gt;&gt; ConfigApp.show(pretty=True)\n          # Pretty printed configuration\n        \"\"\"\n        import yaml\n        from collections import defaultdict\n        from rich.console import Console\n        from rich.syntax import Syntax\n        from snk_cli.utils import convert_key_to_snakemake_format\n\n        def deep_update(source, overrides):\n            for key, value in overrides.items():\n                if isinstance(value, dict):\n                    if not isinstance(source.get(key), dict):\n                        # If the existing value is not a dictionary, replace it with one\n                        source[key] = {}\n                    # Now we are sure that source[key] is a dictionary, so we can update it\n                    deep_update(source[key], value)\n                else:\n                    source[key] = value\n            return source\n\n        collapsed_data = defaultdict(dict)\n        config_dict = [\n            convert_key_to_snakemake_format(option.original_key, option.default)\n            for option in self.options\n        ]\n        for d in config_dict:\n            deep_update(collapsed_data, d)\n        yaml_str = yaml.dump(dict(collapsed_data))\n        if pretty:\n            syntax = Syntax(yaml_str, \"yaml\")\n            console = Console()\n            console.print(syntax)\n        else:\n            typer.echo(yaml_str)\n</code></pre>"},{"location":"reference/subcommands/#src.snk_cli.subcommands.config.ConfigApp.__init__","title":"<code>__init__(workflow, options)</code>","text":"<p>Initializes the ConfigApp class.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>The workflow to configure.</p> required Source code in <code>src/snk_cli/subcommands/config.py</code> <pre><code>def __init__(self, workflow: Workflow, options: List[Option]):\n    \"\"\"\n    Initializes the ConfigApp class.\n\n    Args:\n      workflow (Workflow): The workflow to configure.\n    \"\"\"\n    self.options = options\n    self.workflow = workflow\n    self.register_command(self.config, help=\"Show the workflow configuration.\")\n</code></pre>"},{"location":"reference/subcommands/#src.snk_cli.subcommands.config.ConfigApp.config","title":"<code>config(ctx, pretty=typer.Option(False, '--pretty', '-p'))</code>","text":"<p>Prints the configuration for the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>typer.Context</code> <p>The Typer context.</p> required <code>pretty</code> <code>bool</code> <p>Whether to print the configuration in a pretty format. Defaults to False.</p> <code>typer.Option(False, '--pretty', '-p')</code> <p>Returns:</p> Type Description <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ConfigApp.show(pretty=True)\n# Pretty printed configuration\n</code></pre> Source code in <code>src/snk_cli/subcommands/config.py</code> <pre><code>def config(\n    self, ctx: typer.Context, pretty: bool = typer.Option(False, \"--pretty\", \"-p\")\n):\n    \"\"\"\n    Prints the configuration for the workflow.\n\n    Args:\n      ctx (typer.Context): The Typer context.\n      pretty (bool, optional): Whether to print the configuration in a pretty format. Defaults to False.\n\n    Returns:\n      None\n\n    Examples:\n      &gt;&gt;&gt; ConfigApp.show(pretty=True)\n      # Pretty printed configuration\n    \"\"\"\n    import yaml\n    from collections import defaultdict\n    from rich.console import Console\n    from rich.syntax import Syntax\n    from snk_cli.utils import convert_key_to_snakemake_format\n\n    def deep_update(source, overrides):\n        for key, value in overrides.items():\n            if isinstance(value, dict):\n                if not isinstance(source.get(key), dict):\n                    # If the existing value is not a dictionary, replace it with one\n                    source[key] = {}\n                # Now we are sure that source[key] is a dictionary, so we can update it\n                deep_update(source[key], value)\n            else:\n                source[key] = value\n        return source\n\n    collapsed_data = defaultdict(dict)\n    config_dict = [\n        convert_key_to_snakemake_format(option.original_key, option.default)\n        for option in self.options\n    ]\n    for d in config_dict:\n        deep_update(collapsed_data, d)\n    yaml_str = yaml.dump(dict(collapsed_data))\n    if pretty:\n        syntax = Syntax(yaml_str, \"yaml\")\n        console = Console()\n        console.print(syntax)\n    else:\n        typer.echo(yaml_str)\n</code></pre>"},{"location":"reference/subcommands/#src.snk_cli.subcommands.utils.PersistenceMock","title":"<code>PersistenceMock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Persistence</code></p> <p>Mock for workflow.persistence</p> Source code in <code>src/snk_cli/subcommands/utils.py</code> <pre><code>@dataclass\nclass PersistenceMock(Persistence):\n    \"\"\"\n    Mock for workflow.persistence\n    \"\"\"\n\n    conda_env_path: Path = None\n    _metadata_path: Path = None\n    _incomplete_path: Path = None\n    shadow_path: Path = None\n    conda_env_archive_path: Path = None\n    container_img_path: Path = None\n    aux_path: Path = None\n</code></pre>"},{"location":"reference/testing/","title":"Testing","text":""},{"location":"reference/testing/#src.snk_cli.testing.SnkCliRunner","title":"<code>SnkCliRunner</code>  <code>dataclass</code>","text":"<p>Dynamically creates a CLI Runner for testing.</p> <p>Parameters:</p> Name Type Description Default <code>cli</code> <code>CLI</code> <p>The CLI object to be tested.</p> required <p>Attributes:</p> Name Type Description <code>runner</code> <code>CliRunner</code> <p>The CliRunner object used for testing.</p> Source code in <code>src/snk_cli/testing.py</code> <pre><code>@dataclass\nclass SnkCliRunner:\n    \"\"\"\n    Dynamically creates a CLI Runner for testing.\n\n    Args:\n      cli (CLI): The CLI object to be tested.\n\n    Attributes:\n      runner (CliRunner): The CliRunner object used for testing.\n    \"\"\"\n\n    cli: CLI\n    runner = CliRunner(mix_stderr=False)\n\n    def invoke(self, args: List[str]) -&gt; Result:\n        old_argv = sys.argv\n        sys.argv = ['cli'] + args  # ensure that the CLI is invoked with the correct arguments\n        result = self.runner.invoke(self.cli.app, args)\n        sys.argv = old_argv\n        return result\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#src.snk_cli.utils.check_command_available","title":"<code>check_command_available(command)</code>","text":"<p>Check if a command is available.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the command is available, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; check_command_available('ls')\n</code></pre> Source code in <code>src/snk_cli/utils.py</code> <pre><code>def check_command_available(command: str):\n    \"\"\"\n    Check if a command is available.\n\n    Args:\n      command (str): The command to check.\n\n    Returns:\n      bool: True if the command is available, False otherwise.\n\n    Examples:\n      &gt;&gt;&gt; check_command_available('ls')\n    \"\"\"\n    from shutil import which\n\n    return which(command) is not None\n</code></pre>"},{"location":"reference/utils/#src.snk_cli.utils.convert_key_to_snakemake_format","title":"<code>convert_key_to_snakemake_format(key, value, sep=':')</code>","text":"<p>Convert key to a format that can be passed over the cli to snakemake.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to convert.</p> required <code>value</code> <code>any</code> <p>The value associated with the key.</p> required <code>sep</code> <code>str</code> <p>The separator to use between keys. Defaults to ':'.</p> <code>':'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The converted key-value pair in snakemake format.</p> Source code in <code>src/snk_cli/utils.py</code> <pre><code>def convert_key_to_snakemake_format(key, value, sep=\":\"):\n    \"\"\"\n    Convert key to a format that can be passed over the cli to snakemake.\n\n    Args:\n      key (str): The key to convert.\n      value (any): The value associated with the key.\n      sep (str, optional): The separator to use between keys. Defaults to ':'.\n\n    Returns:\n      dict: The converted key-value pair in snakemake format.\n    \"\"\"\n    result_dict = {}\n    parts = key.split(sep)\n    current_dict = result_dict\n\n    for part in parts[:-1]:\n        current_dict = current_dict.setdefault(part, {})\n\n    current_dict[parts[-1]] = value\n\n    return result_dict\n</code></pre>"},{"location":"reference/utils/#src.snk_cli.utils.flatten","title":"<code>flatten(d, parent_key='', sep=':')</code>","text":"<p>Flattens a nested dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dictionary to flatten.</p> required <code>parent_key</code> <code>str</code> <p>The parent key of the dictionary. Defaults to ''.</p> <code>''</code> <code>sep</code> <code>str</code> <p>The separator to use between keys. Defaults to ':'.</p> <code>':'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A flattened dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = {'a': {'b': 1, 'c': 2}, 'd': 3}\n&gt;&gt;&gt; flatten(d)\n{'a:b': 1, 'a:c': 2, 'd': 3}\n</code></pre> Source code in <code>src/snk_cli/utils.py</code> <pre><code>def flatten(d, parent_key=\"\", sep=\":\"):\n    \"\"\"\n    Flattens a nested dictionary.\n\n    Args:\n      d (dict): The dictionary to flatten.\n      parent_key (str, optional): The parent key of the dictionary. Defaults to ''.\n      sep (str, optional): The separator to use between keys. Defaults to ':'.\n\n    Returns:\n      dict: A flattened dictionary.\n\n    Examples:\n      &gt;&gt;&gt; d = {'a': {'b': 1, 'c': 2}, 'd': 3}\n      &gt;&gt;&gt; flatten(d)\n      {'a:b': 1, 'a:c': 2, 'd': 3}\n    \"\"\"\n    items = []\n    for k, v in d.items():\n        new_key = parent_key + sep + k if parent_key else k\n        if isinstance(v, MutableMapping):\n            items.extend(flatten(v, new_key, sep=sep).items())\n        else:\n            items.append((new_key, v))\n    return dict(items)\n</code></pre>"},{"location":"reference/utils/#src.snk_cli.utils.parse_config_args","title":"<code>parse_config_args(args, options)</code>","text":"<p>Parses a list of arguments and a list of options.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[str]</code> <p>A list of arguments.</p> required <code>options</code> <code>List[Option]</code> <p>A list of options.</p> required <p>Returns:</p> Type Description <p>Tuple[List[str], List[dict]]: A tuple of parsed arguments and config.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parse_config_args(['-name', 'John', '-age', '20'], [{'name': 'name', 'default': '', 'help': '', 'type': 'str', 'required': True}, {'name': 'age', 'default': '', 'help': '', 'type': 'int', 'required': True}])\n(['John', '20'], [{'name': 'name', 'John'}, {'age': 20}])\n</code></pre> Source code in <code>src/snk_cli/utils.py</code> <pre><code>def parse_config_args(args: List[str], options: List[Option]):\n    \"\"\"\n    Parses a list of arguments and a list of options.\n\n    Args:\n      args (List[str]): A list of arguments.\n      options (List[Option]): A list of options.\n\n    Returns:\n      Tuple[List[str], List[dict]]: A tuple of parsed arguments and config.\n\n    Examples:\n      &gt;&gt;&gt; parse_config_args(['-name', 'John', '-age', '20'], [{'name': 'name', 'default': '', 'help': '', 'type': 'str', 'required': True}, {'name': 'age', 'default': '', 'help': '', 'type': 'int', 'required': True}])\n      (['John', '20'], [{'name': 'name', 'John'}, {'age': 20}])\n    \"\"\"\n    names = [op.name for op in options]\n    config = []\n    parsed: List[str] = []\n    flag = None\n    for arg in args:\n        if flag:\n            name = flag.lstrip(\"-\")\n            op = next(op for op in options if op.name == name)\n            if op.updated is False and op.default == serialise(arg):\n                # skip args that don't change\n                flag = None\n                continue\n            if \":\" in op.original_key:\n                samkemake_format_config = convert_key_to_snakemake_format(\n                    op.original_key, arg\n                )\n                name = list(samkemake_format_config.keys())[0]\n                arg = samkemake_format_config[name]\n            config.append({name: serialise(arg)})\n            flag = None\n            continue\n        if arg.startswith(\"-\") and arg.lstrip(\"-\") in names:\n            flag = arg\n            continue\n        parsed.append(arg)\n    parsed.sort()\n    return parsed, config\n</code></pre>"},{"location":"reference/utils/#src.snk_cli.utils.serialise","title":"<code>serialise(d)</code>","text":"<p>Serialises a data structure into a string.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>any</code> <p>The data structure to serialise.</p> required <p>Returns:</p> Name Type Description <code>any</code> <p>The serialised data structure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; serialise({'a': 1, 'b': 2})\n{'a': '1', 'b': '2'}\n</code></pre> Source code in <code>src/snk_cli/utils.py</code> <pre><code>def serialise(d):\n    \"\"\"\n    Serialises a data structure into a string.\n\n    Args:\n      d (any): The data structure to serialise.\n\n    Returns:\n      any: The serialised data structure.\n\n    Examples:\n      &gt;&gt;&gt; serialise({'a': 1, 'b': 2})\n      {'a': '1', 'b': '2'}\n    \"\"\"\n    if isinstance(d, Path) or isinstance(d, datetime):\n        return str(d)\n\n    if isinstance(d, list):\n        return [serialise(x) for x in d]\n\n    if isinstance(d, dict):\n        for k, v in d.items():\n            d.update({k: serialise(v)})\n\n    # return anything else, like a string or number\n    return d\n</code></pre>"},{"location":"reference/validate/","title":"Validate","text":""},{"location":"reference/validate/#src.snk_cli.validate.ValidationError","title":"<code>ValidationError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for all validation exceptions.</p> Source code in <code>src/snk_cli/validate.py</code> <pre><code>class ValidationError(Exception):\n    \"\"\"\n    Base class for all validation exceptions.\n    \"\"\"\n</code></pre>"},{"location":"reference/validate/#src.snk_cli.validate.validate_and_transform_in_place","title":"<code>validate_and_transform_in_place(config, validation, replace_none=True)</code>","text":"<p>Validates the config against the snk config. Will convert values to the correct type if possible.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The config to validate.</p> required <code>validation</code> <code>dict</code> <p>The validation dict.</p> required <code>replace_none</code> <code>bool</code> <p>If True, replace 'None' with None.</p> <code>True</code> Source code in <code>src/snk_cli/validate.py</code> <pre><code>def validate_and_transform_in_place(config: Dict[str, Any], validation: ValidationDict, replace_none: bool = True) -&gt; None:\n    \"\"\"\n    Validates the config against the snk config.\n    Will convert values to the correct type if possible.\n\n    Args:\n      config (dict): The config to validate.\n      validation (dict): The validation dict.\n      replace_none (bool): If True, replace 'None' with None.\n    \"\"\"\n    for key, value in list(config.items()):\n        if key not in validation:\n            continue  # Optionally handle unexpected keys\n        if value == 'None' and replace_none:\n            config[key] = None\n            continue\n        if value is None:\n            continue\n        val_info = validation[key]\n        if isinstance(val_info, dict) and 'type' in val_info:\n            # Direct type validation\n            val_type = types.get(val_info[\"type\"].lower(), None)\n            if val_type is None:\n                raise ValueError(f\"Unknown type '{val_info['type']}'\")\n            try:\n                if getattr(val_type, \"__origin__\", None) == list:\n                    val_type = val_type.__args__[0]\n                    if not isinstance(value, list):\n                        raise ValueError(f\"Expected a list for key '{key}'\")\n                    config[key] = [val_type(v) for v in value]\n                else:\n                    config[key] = val_type(value)\n            except (ValueError, TypeError) as e:\n                raise ValueError(f\"Type conversion error for key '{key}': {e}\")\n        elif isinstance(value, dict):\n            # Nested dictionary validation\n            validate_and_transform_in_place(value, val_info)\n</code></pre>"},{"location":"reference/validate/#src.snk_cli.validate.validate_config","title":"<code>validate_config(config, snk_config_path)</code>","text":"<p>Validates the config against the snk config. Will convert values to the correct type if possible.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The config to validate.</p> required <code>snk_config_path</code> <code>Path</code> <p>The path to the snk config.</p> required Source code in <code>src/snk_cli/validate.py</code> <pre><code>def validate_config(config: Dict[str, Any], snk_config_path: Path) -&gt; None:\n    \"\"\"\n    Validates the config against the snk config.\n    Will convert values to the correct type if possible.\n\n    Args:\n      config (dict): The config to validate.\n      snk_config_path (Path): The path to the snk config.\n    \"\"\"\n    snk_config_path = Path(snk_config_path)\n    # if relative path, make absolute to \n    if not snk_config_path.is_absolute():\n        frame = inspect.currentframe().f_back\n        workflow = frame.f_globals.get(\"workflow\")\n        snk_config_path = Path(workflow.current_basedir) / snk_config_path\n\n    snk_config = SnkConfig.from_path(snk_config_path)\n    validate_and_transform_in_place(config, snk_config.cli)\n</code></pre>"},{"location":"reference/workflow/","title":"Workflow","text":""},{"location":"reference/workflow/#src.snk_cli.workflow.Workflow","title":"<code>Workflow</code>","text":"<p>Represents a workflow.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>The path to the workflow.</p> <code>repo</code> <code>Repo</code> <p>The git repository of the workflow.</p> <code>name</code> <code>str</code> <p>The name of the workflow.</p> Source code in <code>src/snk_cli/workflow.py</code> <pre><code>class Workflow:\n    \"\"\"\n    Represents a workflow.\n\n    Attributes:\n      path (Path): The path to the workflow.\n      repo (Repo): The git repository of the workflow.\n      name (str): The name of the workflow.\n    \"\"\"\n\n    def __init__(self, path: Path) -&gt; None:\n        \"\"\"\n        Initializes a Workflow object.\n\n        Args:\n          path (Path): The path to the workflow.\n\n        Returns:\n          None\n\n        Notes:\n          Initializes the `repo` and `name` attributes.\n        \"\"\"\n        self.path = path\n        self.editable = self.check_is_editable()\n        if self.editable:  # editable mode\n            self.repo = None\n        else:\n            try:\n                self.repo = Repo(path)\n            except InvalidGitRepositoryError:\n                self.repo = None\n        self.name = self.path.name\n\n\n    @property\n    def tag(self):\n        \"\"\"\n        Gets the tag of the workflow.\n\n        Returns:\n          str: The tag of the workflow, or None if no tag is found.\n        \"\"\"\n        try:\n            tag = self.repo.git.describe([\"--tags\", \"--exact-match\"])\n        except Exception:\n            tag = None\n        return tag\n\n    @property\n    def commit(self):\n        \"\"\"\n        Gets the commit SHA of the workflow.\n\n        Returns:\n          str: The commit SHA of the workflow.\n        \"\"\"\n        try:\n            sha = self.repo.head.object.hexsha\n            commit = self.repo.git.rev_parse(sha, short=8)\n        except Exception:\n           commit = None\n        return commit\n\n    @property\n    def version(self):\n        \"\"\"\n        Gets the version of the workflow.\n\n        Returns:\n          str: The version of the workflow, or None if no version is found.\n        \"\"\"\n        if self.repo is None:\n            return None\n        if self.tag:\n            version = self.tag\n        else:\n            version = self.commit\n        return version\n\n    @property\n    def executable(self):\n        \"\"\"\n        Gets the executable of the workflow.\n\n        Returns:\n          Path: The path to the workflow executable.\n        \"\"\"\n        workflow_bin_dir = self.path.parent.parent / \"bin\"\n        name = self.name\n        if sys.platform.startswith(\"win\"):\n            name += \".exe\"\n        return workflow_bin_dir / name\n\n    @property\n    def conda_prefix_dir(self):\n        \"\"\"\n        Gets the conda prefix directory of the workflow. If in editable mode, the conda prefix directory is located in the .snakemake directory. Otherwise, it is located in the .conda directory in the workflow directory.\n\n        Returns:\n          Path: The path to the conda prefix directory.\n        \"\"\"\n        return Path(\".snakemake\") / \"conda\" if self.editable else self.path / \".conda\"\n\n    @property\n    def singularity_prefix_dir(self):\n        \"\"\"\n        Gets the singularity prefix directory of the workflow.\n\n        Returns:\n          Path: The path to the singularity prefix directory.\n        \"\"\"\n        if \" \" in str(self.path):\n            # sigh, snakemake singularity does not support spaces in the path\n            # https://github.com/snakemake/snakemake/blob/2ecb21ba04088b9e6850447760f713784cf8b775/snakemake/deployment/singularity.py#L130C1-L131C1\n            return None\n        return Path(\".snakemake\") / \"singularity\" if self.editable else self.path / \".singularity\"\n\n    def _is_editable_pip_install(self):\n        # This function now acts as a method within the Workflow class\n        package_spec = importlib.util.find_spec(self.name)\n        if package_spec is None:\n            return False  # Package is not installed\n\n        package_location = package_spec.origin\n        site_packages_paths = [p for p in sys.path if 'site-packages' in p]\n        is_inside_site_packages = any(package_location.startswith(sp) for sp in site_packages_paths)\n\n        if not is_inside_site_packages:\n            return True\n\n        for sp in site_packages_paths:\n            egg_link_path = os.path.join(sp, self.name + '.egg-link')\n            if os.path.isfile(egg_link_path):\n                return True\n\n        return False\n\n    def check_is_editable(self):\n        \"\"\"\n        Is the workflow editable?\n\n        Returns:\n          bool: True if the workflow is editable, False otherwise.\n        \"\"\"\n        if self.path.is_symlink():\n            return True\n        try:\n            return self._is_editable_pip_install()\n        except Exception:\n            return False\n\n    def _find_folder(self, name) -&gt; Optional[Path]:\n        \"\"\"\n        Search for folder.\n\n        Args:\n          name: The name of the folder to search for.\n\n        Returns:\n          Optional[Path]: The path to the folder, or None if the folder is not found.\n        \"\"\"\n        if (self.path / \"workflow\" / name).exists():\n            return self.path / \"workflow\" / name\n        if (self.path / name).exists():\n            return self.path / name\n        return None\n\n    @property\n    def profiles(self):\n        workflow_profile_dir = self._find_folder(\"profiles\")\n        if workflow_profile_dir:\n            return [p for p in workflow_profile_dir.glob(\"*\") if p.is_dir() and (p / \"config.yaml\").exists()]\n        return []\n\n    @property\n    def environments(self):\n        workflow_environments_dir = self._find_folder(\"envs\")\n        if workflow_environments_dir:\n            return [e for e in workflow_environments_dir.glob(\"*.yaml\")] + [\n                e for e in workflow_environments_dir.glob(\"*.yml\")\n            ]\n        return []\n\n    @property\n    def scripts(self):\n        workflow_environments_dir = self._find_folder(\"scripts\")\n        if workflow_environments_dir:\n            return [s for s in workflow_environments_dir.iterdir() if s.is_file()]\n        return []\n</code></pre>"},{"location":"reference/workflow/#src.snk_cli.workflow.Workflow.commit","title":"<code>commit</code>  <code>property</code>","text":"<p>Gets the commit SHA of the workflow.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The commit SHA of the workflow.</p>"},{"location":"reference/workflow/#src.snk_cli.workflow.Workflow.conda_prefix_dir","title":"<code>conda_prefix_dir</code>  <code>property</code>","text":"<p>Gets the conda prefix directory of the workflow. If in editable mode, the conda prefix directory is located in the .snakemake directory. Otherwise, it is located in the .conda directory in the workflow directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <p>The path to the conda prefix directory.</p>"},{"location":"reference/workflow/#src.snk_cli.workflow.Workflow.executable","title":"<code>executable</code>  <code>property</code>","text":"<p>Gets the executable of the workflow.</p> <p>Returns:</p> Name Type Description <code>Path</code> <p>The path to the workflow executable.</p>"},{"location":"reference/workflow/#src.snk_cli.workflow.Workflow.singularity_prefix_dir","title":"<code>singularity_prefix_dir</code>  <code>property</code>","text":"<p>Gets the singularity prefix directory of the workflow.</p> <p>Returns:</p> Name Type Description <code>Path</code> <p>The path to the singularity prefix directory.</p>"},{"location":"reference/workflow/#src.snk_cli.workflow.Workflow.tag","title":"<code>tag</code>  <code>property</code>","text":"<p>Gets the tag of the workflow.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The tag of the workflow, or None if no tag is found.</p>"},{"location":"reference/workflow/#src.snk_cli.workflow.Workflow.version","title":"<code>version</code>  <code>property</code>","text":"<p>Gets the version of the workflow.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The version of the workflow, or None if no version is found.</p>"},{"location":"reference/workflow/#src.snk_cli.workflow.Workflow.__init__","title":"<code>__init__(path)</code>","text":"<p>Initializes a Workflow object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the workflow.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Notes <p>Initializes the <code>repo</code> and <code>name</code> attributes.</p> Source code in <code>src/snk_cli/workflow.py</code> <pre><code>def __init__(self, path: Path) -&gt; None:\n    \"\"\"\n    Initializes a Workflow object.\n\n    Args:\n      path (Path): The path to the workflow.\n\n    Returns:\n      None\n\n    Notes:\n      Initializes the `repo` and `name` attributes.\n    \"\"\"\n    self.path = path\n    self.editable = self.check_is_editable()\n    if self.editable:  # editable mode\n        self.repo = None\n    else:\n        try:\n            self.repo = Repo(path)\n        except InvalidGitRepositoryError:\n            self.repo = None\n    self.name = self.path.name\n</code></pre>"},{"location":"reference/workflow/#src.snk_cli.workflow.Workflow.check_is_editable","title":"<code>check_is_editable()</code>","text":"<p>Is the workflow editable?</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the workflow is editable, False otherwise.</p> Source code in <code>src/snk_cli/workflow.py</code> <pre><code>def check_is_editable(self):\n    \"\"\"\n    Is the workflow editable?\n\n    Returns:\n      bool: True if the workflow is editable, False otherwise.\n    \"\"\"\n    if self.path.is_symlink():\n        return True\n    try:\n        return self._is_editable_pip_install()\n    except Exception:\n        return False\n</code></pre>"}]}